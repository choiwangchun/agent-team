<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title><%= pageTitle %></title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&family=Sora:wght@500;600;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/css/tailwind.css?v=<%= assetVersion %>" />
  </head>
  <body class="min-h-screen bg-gradient-to-br from-[#e8f7ff] via-[#f8fbff] to-[#fff3ed]">
    <div id="appShell" class="mx-auto hidden max-w-7xl px-4 py-6 sm:px-6 lg:px-8">
      <div class="grid gap-6 lg:grid-cols-[280px,1fr]">
        <aside
          class="flex flex-col rounded-3xl border border-white/70 bg-white/90 p-5 shadow-soft backdrop-blur lg:sticky lg:top-6 lg:h-[calc(100vh-3rem)] lg:overflow-y-auto"
        >
          <div class="flex items-center gap-3">
            <div class="flex h-11 w-11 items-center justify-center rounded-2xl bg-ink text-sm font-bold text-white">AG</div>
            <div>
              <p class="font-display text-sm font-semibold">Agent Workspace</p>
              <p class="text-xs text-slate-500">Control Cockpit</p>
            </div>
          </div>

          <nav class="mt-7" aria-label="Agent menu">
            <p class="mb-3 px-2 text-xs uppercase tracking-[0.2em] text-slate-400">Sidebar</p>
            <ul class="space-y-2 text-sm" id="sidebarMenu">
              <li>
                <button
                  type="button"
                  data-tab="auth-api"
                  class="tab-btn flex w-full items-center justify-between rounded-2xl px-4 py-3 font-semibold transition"
                >
                  <span>Auth & API</span>
                  <span class="rounded-full bg-slate-100 px-2 py-0.5 text-xs text-slate-500">Auth</span>
                </button>
              </li>
              <li>
                <button
                  type="button"
                  data-tab="data-processing"
                  class="tab-btn flex w-full items-center justify-between rounded-2xl px-4 py-3 font-semibold transition"
                >
                  <span>데이터 처리</span>
                  <span class="rounded-full bg-slate-100 px-2 py-0.5 text-xs text-slate-500">Pipeline</span>
                </button>
              </li>
              <li>
                <button
                  type="button"
                  data-tab="agent-creation"
                  class="tab-btn flex w-full items-center justify-between rounded-2xl px-4 py-3 font-semibold transition"
                >
                  <span>agent 생성</span>
                  <span class="rounded-full bg-slate-100 px-2 py-0.5 text-xs text-slate-500">Builder</span>
                </button>
              </li>
              <li>
                <button
                  type="button"
                  data-tab="agent-deployment"
                  class="tab-btn flex w-full items-center justify-between rounded-2xl px-4 py-3 font-semibold transition"
                >
                  <span>agent 배치</span>
                  <span class="rounded-full bg-slate-100 px-2 py-0.5 text-xs text-slate-500">Rollout</span>
                </button>
              </li>
            </ul>
          </nav>

          <div class="mt-auto rounded-2xl border border-slate-200 bg-slate-50 px-4 py-3">
            <p class="text-xs text-slate-500">Signed in as</p>
            <p id="signedInUser" class="font-semibold text-slate-900"><%= user.name %> (<%= user.role %>)</p>
            <button
              id="logoutBtn"
              type="button"
              class="mt-2 w-full rounded-lg border border-slate-200 bg-white px-3 py-1.5 text-xs font-semibold text-slate-700 transition hover:bg-slate-100"
            >
              로그아웃
            </button>
          </div>
        </aside>

        <section class="min-w-0">
          <main class="min-w-0">
            <section data-panel="auth-api" class="tab-panel hidden min-w-0 max-w-full rounded-3xl bg-white p-6 shadow-soft">
  <div class="flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between">
    <div>
      <h2 class="font-display text-xl font-semibold">Auth & API 인증</h2>
      <p class="mt-1 text-sm text-slate-500">Provider를 인증하면 Agent 생성에서 모델을 선택할 수 있습니다.</p>
    </div>
    <span class="rounded-full bg-[#eef6ff] px-3 py-1 text-xs font-semibold text-electric">Model Access Hub</span>
  </div>

  <div id="apNotice" class="mt-4 hidden rounded-xl border px-3 py-2 text-sm"></div>

  <article class="mt-6 rounded-2xl border border-slate-100 bg-slate-50 p-5">
    <h3 class="font-semibold text-slate-900">인증된 Provider</h3>

    <ul id="apProviderList" class="mt-4 space-y-3 text-sm">
      <li class="rounded-xl border border-slate-200 bg-white p-3 text-slate-500">인증 항목을 불러오는 중입니다...</li>
    </ul>
  </article>
</section>

            <section data-panel="data-processing" class="tab-panel min-w-0 max-w-full rounded-3xl bg-white p-6 shadow-soft">
  <div class="flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between">
    <div>
      <h2 class="font-display text-xl font-semibold">데이터 처리</h2>
      <p class="mt-1 text-sm text-slate-500">기존 파이프라인 대신, 전면 재빌딩을 위한 새 구조 템플릿입니다.</p>
    </div>
    <span class="rounded-full bg-[#e8f7ff] px-3 py-1 text-xs font-semibold text-electric">Rebuild Blueprint</span>
  </div>

  <div id="dpNotice" class="mt-4 hidden rounded-xl border px-3 py-2 text-sm"></div>

  <article class="mt-6 rounded-2xl border border-slate-100 bg-slate-50 p-5">
    <h3 class="font-semibold text-slate-900">데이터 드래그 앤 드롭 업로드</h3>
    <p class="mt-1 text-sm text-slate-500">(csv, json, ...등 다양한 데이터 베이스 형식 지원)</p>

    <input id="dpHiddenFileInput" type="file" accept=".csv,.json,.xls,.xlsx,.tsv,.txt" class="hidden" />
    <div id="dpUploadWrap" class="mt-5">
      <div
        id="dpDropZone"
        class="rounded-2xl border-2 border-dashed border-slate-300 bg-white px-4 py-7 text-center transition hover:border-electric/60"
      >
        <p class="text-sm font-semibold text-slate-700">여기로 파일을 드래그 앤 드롭하세요</p>
        <p class="mt-1 text-xs text-slate-500">또는 아래 버튼으로 파일 선택</p>
        <button
          id="dpPickFileBtn"
          type="button"
          class="mt-3 rounded-xl border border-slate-200 bg-white px-4 py-2 text-sm font-semibold text-slate-700 transition hover:bg-slate-100"
        >
          파일 선택
        </button>
        <p id="dpFileMeta" class="mt-2 text-xs text-slate-500">아직 선택된 파일이 없습니다.</p>
      </div>
    </div>

    <div id="dpPreviewWrap" class="mt-5 hidden min-w-0 max-w-full rounded-2xl border border-slate-200 bg-white p-3">
      <div class="flex flex-wrap items-center justify-between gap-2">
        <div>
          <h4 class="text-sm font-semibold text-slate-900">데이터 프리뷰</h4>
          <p id="dpPreviewMeta" class="mt-0.5 text-xs text-slate-500">프리뷰 정보를 준비 중입니다.</p>
        </div>
        <button
          id="dpResetUploadBtn"
          type="button"
          class="rounded-lg border border-slate-200 bg-white px-3 py-1.5 text-xs font-semibold text-slate-700 transition hover:bg-slate-100"
        >
          다른 파일 업로드
        </button>
      </div>
      <div class="mt-3 max-h-[420px] max-w-full overflow-x-auto overflow-y-auto rounded-xl border border-slate-200">
        <table class="w-max min-w-full text-left text-xs">
          <thead id="dpPreviewHead" class="bg-slate-50 text-slate-600"></thead>
          <tbody id="dpPreviewBody" class="text-slate-700"></tbody>
        </table>
      </div>
      <p id="dpPreviewEmpty" class="mt-2 text-xs text-slate-500">미리볼 데이터가 없습니다.</p>
    </div>

    <div class="mt-4 rounded-xl border border-slate-200 bg-white p-3">
      <h4 class="text-xs font-semibold uppercase tracking-wide text-slate-500">추출된 Feature</h4>
      <div id="dpFeatureList" class="mt-2 flex flex-wrap gap-2"></div>
      <p id="dpFeatureEmpty" class="text-sm text-slate-500">아직 feature를 추출하지 않았습니다.</p>
    </div>
  </article>

  <article class="mt-5 rounded-2xl border border-slate-100 bg-slate-50 p-5">
    <h3 class="font-semibold text-slate-900">명령창</h3>
    <p class="mt-1 text-sm text-slate-500">
      여기서 명령을 실행하면 codex나 claude code처럼 agent가 일하는 로그를 볼 수 있습니다.
      기본으로 탑재된 데이터 엔지니어 agent가 데이터 분석, 데이터 전처리를 action 할 수 있게 구현할 예정입니다.
    </p>
    <pre
      id="dpCommandLog"
      class="mt-3 h-44 overflow-auto rounded-xl border border-slate-200 bg-[#0b1221] p-3 font-mono text-xs text-[#d9e5ff]"
    >[system] help, status, list features, clear features</pre>
    <form id="dpCommandForm" class="mt-3 flex flex-row flex-nowrap items-center gap-2">
      <input
        id="dpCommandInput"
        type="text"
        placeholder="예: list features"
        class="min-w-0 flex-1 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm outline-none ring-electric/30 transition focus:ring"
      />
      <button
        type="submit"
        class="shrink-0 whitespace-nowrap rounded-xl bg-ink px-4 py-2 text-sm font-semibold text-white transition hover:bg-slate-800 min-w-[84px]"
      >
        실행
      </button>
    </form>
  </article>
</section>


            <section data-panel="agent-creation" class="tab-panel hidden min-w-0 max-w-full rounded-3xl bg-white p-6 shadow-soft">
  <div class="flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between">
    <div>
      <h2 class="font-display text-xl font-semibold">agent 생성</h2>
      <p class="mt-1 text-sm text-slate-500">이름, 시스템 인스트럭션, 스킬, 아바타를 설정해 에이전트를 생성합니다.</p>
    </div>
    <span class="rounded-full bg-[#fff1eb] px-3 py-1 text-xs font-semibold text-coral">Builder Studio</span>
  </div>

  <div id="acNotice" class="mt-4 hidden rounded-xl border px-3 py-2 text-sm"></div>

  <div class="mt-6 grid gap-6 md:grid-cols-3">
    <div class="space-y-4 md:col-span-2">
      <article class="rounded-2xl border border-slate-100 bg-slate-50 p-5">
        <h3 class="font-semibold text-slate-900">Agent 이름 설정</h3>
        <label class="mt-3 block text-sm">
          <span class="mb-1 block text-xs uppercase tracking-wide text-slate-500">Agent Name</span>
          <input
            id="acName"
            type="text"
            value="Growth Analyst Agent"
            class="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm outline-none ring-electric/30 transition focus:ring"
          />
        </label>
      </article>

      <article class="rounded-2xl border border-slate-100 bg-slate-50 p-5">
        <h3 class="font-semibold text-slate-900">Agent 모델 선택</h3>
        <p class="mt-1 text-sm text-slate-500">Auth & API 탭에서 인증한 모델을 선택할 수 있습니다.</p>
        <label class="mt-3 block text-sm">
          <span class="mb-1 block text-xs uppercase tracking-wide text-slate-500">Model</span>
          <select
            id="acModelSelect"
            class="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm outline-none ring-electric/30 transition focus:ring"
          >
            <option value="Balanced (default)">Balanced (default)</option>
          </select>
        </label>
      </article>

      <article class="rounded-2xl border border-slate-100 bg-slate-50 p-5">
        <h3 class="font-semibold text-slate-900">Agent 시스템 인스트럭션</h3>
        <label class="mt-3 block text-sm">
          <span class="mb-1 block text-xs uppercase tracking-wide text-slate-500">System Prompt</span>
          <textarea
            id="acPrompt"
            rows="7"
            class="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm outline-none ring-electric/30 transition focus:ring"
          >You are a data-focused growth analyst. Prioritize actionable insights with measurable KPI impact.</textarea>
        </label>
      </article>

      <article class="rounded-2xl border border-slate-100 bg-slate-50 p-5">
        <div class="flex items-center justify-between gap-2">
          <h3 class="font-semibold text-slate-900">Agent 사용할 스킬들</h3>
          <button
            id="acClearSkillsBtn"
            type="button"
            class="rounded-lg border border-slate-200 bg-white px-2.5 py-1.5 text-xs font-semibold text-slate-700 transition hover:bg-slate-100"
          >
            스킬 전체 해제
          </button>
        </div>
        <p class="mt-1 text-sm text-slate-500">내 스킬 목록에서 필요한 스킬을 선택합니다.</p>
        <div id="acSkillList" class="mt-3 grid gap-2 sm:grid-cols-2">
          <p class="rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-500 sm:col-span-2">스킬 목록을 불러오는 중입니다...</p>
        </div>
      </article>
    </div>

    <div class="space-y-4 md:col-span-1">
      <article class="rounded-2xl border border-slate-100 bg-slate-50 p-5">
        <h3 class="font-semibold text-slate-900">avatars</h3>
        <div class="relative mt-3 flex h-80 items-center justify-center overflow-hidden rounded-2xl border border-slate-200 bg-white">
          <img id="acAvatarImage" alt="Agent avatar" class="hidden max-h-56 w-auto object-contain" />
          <p id="acAvatarEmpty" class="px-4 text-center text-xs text-slate-500">아바타를 불러오는 중입니다...</p>
          <div id="acAvatarLoading" class="pointer-events-none absolute inset-0 hidden items-center justify-center bg-white/70 backdrop-blur">
            <div class="flex items-center gap-2 rounded-full border border-slate-200 bg-white px-3 py-1.5 text-xs font-semibold text-slate-700 shadow-soft">
              <span class="h-3.5 w-3.5 animate-spin rounded-full border-2 border-slate-300 border-t-electric"></span>
              <span>아바타 불러오는 중...</span>
            </div>
          </div>
        </div>
      </article>

      <button
        id="acRerollAvatarBtn"
        class="w-full rounded-xl border border-slate-200 bg-white px-4 py-3 text-sm font-semibold text-slate-700 transition hover:bg-slate-100"
      >
        avatars 다시 뽑기
      </button>
      <button id="acCreateBtn" class="w-full rounded-xl bg-ink px-4 py-3 text-sm font-semibold text-white transition hover:bg-slate-800">Agent 생성하기</button>
    </div>
  </div>

  <article class="mt-6 rounded-2xl border border-slate-100 bg-slate-50 p-5">
    <h3 class="font-semibold text-slate-900">최근 생성된 Agent</h3>
    <ul id="acAgentList" class="mt-4 space-y-3 text-sm">
      <li class="rounded-xl border border-slate-200 bg-white p-3 text-slate-500">아직 생성된 Agent가 없습니다.</li>
    </ul>
  </article>
</section>


            <section data-panel="agent-deployment" class="tab-panel hidden min-w-0 max-w-full rounded-3xl bg-white p-6 shadow-soft">
  <div class="flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between">
    <div>
      <h2 class="font-display text-xl font-semibold">agent 배치</h2>
      <p class="mt-1 text-sm text-slate-500">생성된 Agent를 우측 목록에서 드래그해 캔버스에 배치하고, node-to-node로 연결합니다.</p>
    </div>
    <span class="rounded-full bg-[#e9fff5] px-3 py-1 text-xs font-semibold text-neon">Node Flow Studio</span>
  </div>

  <div id="adNotice" class="mt-4 hidden rounded-xl border px-3 py-2 text-sm"></div>

  <div class="mt-6 grid gap-6 lg:grid-cols-[minmax(0,1fr)_260px]">
    <div class="space-y-4">
      <article class="rounded-2xl border border-slate-100 bg-slate-50 p-5">
        <h3 class="font-semibold text-slate-900">Agent를 node to node로 연결 할 수 있게 만드는 패널</h3>
        <p class="mt-1 text-sm text-slate-500">우측의 생성된 Agent 카드를 드래그해 캔버스에 놓으세요.</p>

        <div
          id="adCanvas"
          class="relative mt-4 h-[420px] overflow-hidden rounded-2xl border border-slate-200 bg-white ring-electric/30 transition"
        >
          <div id="adStage" class="absolute left-0 top-0 origin-top-left">
            <svg id="adEdgeLayer" class="pointer-events-none absolute inset-0 h-full w-full"></svg>
            <div id="adNodeLayer" class="absolute inset-0"></div>
          </div>
          <p id="adCanvasEmpty" class="absolute inset-0 flex items-center justify-center px-4 text-center text-base font-semibold text-slate-400">
            드래그 앤 드롭으로 가져다 놓을 수 있음
          </p>
        </div>

        <div class="mt-3 flex flex-wrap items-center gap-2">
          <button
            id="adConnectModeBtn"
            class="rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-semibold text-slate-700 transition hover:bg-slate-100"
          >
            연결 모드 OFF
          </button>
          <button
            id="adClearCanvasBtn"
            class="rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-semibold text-slate-700 transition hover:bg-slate-100"
          >
            캔버스 초기화
          </button>
          <button
            id="adZoomOutBtn"
            class="rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-semibold text-slate-700 transition hover:bg-slate-100"
          >
            줌 아웃
          </button>
          <button
            id="adZoomInBtn"
            class="rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-semibold text-slate-700 transition hover:bg-slate-100"
          >
            줌 인
          </button>
          <button
            id="adZoomResetBtn"
            class="rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm font-semibold text-slate-700 transition hover:bg-slate-100"
          >
            줌 초기화
          </button>
          <span id="adZoomLabel" class="rounded-xl border border-slate-200 bg-slate-100 px-3 py-2 text-sm font-semibold text-slate-700">100%</span>
        </div>

        <div class="mt-3 grid gap-3 xl:grid-cols-2">
          <div class="rounded-xl border border-slate-200 bg-white p-3">
            <h4 class="text-xs font-semibold uppercase tracking-wide text-slate-500">연결된 라인</h4>
            <ul id="adEdgeList" class="mt-2 space-y-2 text-sm">
              <li class="rounded-lg border border-slate-100 bg-slate-50 px-2 py-1 text-slate-500">아직 연결된 노드가 없습니다.</li>
            </ul>
          </div>

          <div class="rounded-xl border border-slate-200 bg-white p-3">
            <div class="flex items-center justify-between gap-2">
              <h4 class="text-xs font-semibold uppercase tracking-wide text-slate-500">선택 노드 Feature</h4>
              <div class="flex items-center gap-1">
                <button
                  id="adAssignAllNodeFeaturesBtn"
                  type="button"
                  class="rounded-lg border border-slate-200 bg-white px-2 py-1 text-[11px] font-semibold text-slate-700 transition hover:bg-slate-100"
                >
                  전체 선택
                </button>
                <button
                  id="adClearNodeFeaturesBtn"
                  type="button"
                  class="rounded-lg border border-slate-200 bg-white px-2 py-1 text-[11px] font-semibold text-slate-700 transition hover:bg-slate-100"
                >
                  선택 해제
                </button>
              </div>
            </div>
            <p id="adSelectedNodeMeta" class="mt-2 text-xs text-slate-500">노드를 클릭하면 사용할 feature를 설정할 수 있습니다.</p>
            <div id="adNodeFeatureList" class="mt-2 grid max-h-28 gap-1 overflow-auto pr-1"></div>
            <p id="adNodeFeatureEmpty" class="mt-2 text-xs text-slate-500">데이터 처리 탭에서 feature를 추출하면 여기서 선택할 수 있습니다.</p>
          </div>
        </div>
      </article>

      <article class="rounded-2xl border border-slate-100 bg-slate-50 p-5">
        <h3 class="font-semibold text-slate-900">명령창</h3>
        <p class="mt-1 text-sm text-slate-500">명령을 입력하면 agent 실행 로그처럼 콘솔 형태로 출력됩니다.</p>
        <pre
          id="adCommandLog"
          class="mt-3 h-44 overflow-auto rounded-xl border border-slate-200 bg-[#0b1221] p-3 font-mono text-xs text-[#d9e5ff]"
        >[system] help, list nodes, list edges, connect node-1 node-2, clear</pre>
        <form id="adCommandForm" class="mt-3 flex flex-row flex-nowrap items-center gap-2">
          <input
            id="adCommandInput"
            type="text"
            placeholder="예: list nodes"
            class="min-w-0 flex-1 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm outline-none ring-electric/30 transition focus:ring"
          />
          <button
            type="submit"
            class="shrink-0 whitespace-nowrap rounded-xl bg-ink px-4 py-2 text-sm font-semibold text-white transition hover:bg-slate-800 min-w-[84px]"
          >
            실행
          </button>
        </form>
      </article>
    </div>

    <article class="rounded-2xl border border-slate-100 bg-slate-50 p-4">
      <div class="rounded-xl border border-slate-200 bg-white p-3">
        <h3 class="font-semibold text-slate-900">사용 가능한 Feature</h3>
        <div id="adFeaturePool" class="mt-2 flex max-h-40 flex-wrap gap-2 overflow-auto pr-1"></div>
        <p id="adFeaturePoolEmpty" class="mt-2 text-xs text-slate-500">데이터 처리 탭에서 feature를 추출하면 배치 탭에서 바로 사용 가능합니다.</p>
      </div>

      <h3 class="mt-4 font-semibold text-slate-900">생성된 Agent</h3>
      <p class="mt-1 text-xs text-slate-500">캔버스로 드래그해 배치</p>
      <ul id="adAgentSourceList" class="mt-3 space-y-2">
        <li class="rounded-xl border border-slate-200 bg-white p-3 text-sm text-slate-500">아직 생성된 Agent가 없습니다.</li>
      </ul>
    </article>
  </div>
</section>

          </main>
        </section>
      </div>
    </div>

    <div id="authGate" class="fixed inset-0 z-50 flex items-center justify-center bg-slate-950/20 px-4 py-8 backdrop-blur">
      <div class="w-full max-w-md rounded-3xl border border-white/70 bg-white p-6 shadow-soft">
        <h1 class="font-display text-xl font-semibold text-slate-900">로그인</h1>
        <p class="mt-1 text-sm text-slate-500">Agent Workspace를 사용하려면 로그인하세요.</p>

        <div id="authNotice" class="mt-4 rounded-xl border border-sky-200 bg-sky-50 px-3 py-2 text-sm text-sky-800">
          세션을 확인하는 중입니다.
        </div>

        <form id="loginForm" class="mt-4 space-y-3">
          <label class="block text-sm">
            <span class="mb-1 block text-xs uppercase tracking-wide text-slate-500">Email</span>
            <input
              id="loginEmail"
              type="email"
              autocomplete="username"
              value="admin@agent.local"
              class="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm outline-none ring-electric/30 transition focus:ring"
              required
            />
          </label>

          <label class="block text-sm">
            <span class="mb-1 block text-xs uppercase tracking-wide text-slate-500">Password</span>
            <input
              id="loginPassword"
              type="password"
              autocomplete="current-password"
              class="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm outline-none ring-electric/30 transition focus:ring"
              required
            />
          </label>

          <button
            id="loginSubmitBtn"
            type="submit"
            class="w-full rounded-xl bg-ink px-4 py-2.5 text-sm font-semibold text-white transition hover:bg-slate-800"
          >
            로그인
          </button>
        </form>
      </div>
    </div>

    <script>
      (() => {
        const buttons = Array.from(document.querySelectorAll('.tab-btn'));
        const panels = Array.from(document.querySelectorAll('.tab-panel'));
        const inactiveClasses = ['text-slate-700', 'hover:bg-slate-100', 'hover:text-slate-900'];
        const appShell = document.getElementById('appShell');
        const auth = {
          gate: document.getElementById('authGate'),
          notice: document.getElementById('authNotice'),
          form: document.getElementById('loginForm'),
          email: document.getElementById('loginEmail'),
          password: document.getElementById('loginPassword'),
          submitBtn: document.getElementById('loginSubmitBtn'),
          signedInUser: document.getElementById('signedInUser'),
          logoutBtn: document.getElementById('logoutBtn'),
        };

        function setTab(nextTab, pushHash = true) {
          buttons.forEach((button) => {
            const isActive = button.dataset.tab === nextTab;
            button.classList.toggle('bg-ink', isActive);
            button.classList.toggle('text-white', isActive);
            button.classList.toggle('shadow-soft', isActive);
            button.classList.toggle('text-slate-700', !isActive);
            button.classList.toggle('hover:bg-slate-100', !isActive);
            button.classList.toggle('hover:text-slate-900', !isActive);
            button.setAttribute('aria-current', isActive ? 'page' : 'false');
          });

          panels.forEach((panel) => {
            const isActive = panel.dataset.panel === nextTab;
            panel.classList.toggle('hidden', !isActive);
          });

          if (pushHash) {
            window.history.replaceState(null, '', `#${nextTab}`);
          }
        }

        buttons.forEach((button) => {
          inactiveClasses.forEach((name) => button.classList.add(name));
          button.addEventListener('click', () => setTab(button.dataset.tab));
        });

        const initialHash = window.location.hash.replace('#', '');
        const initialTab = buttons.some((button) => button.dataset.tab === initialHash)
          ? initialHash
          : 'data-processing';

        setTab(initialTab, false);

        function escapeHtml(value) {
          return String(value)
            .replaceAll('&', '&amp;')
            .replaceAll('<', '&lt;')
            .replaceAll('>', '&gt;')
            .replaceAll('"', '&quot;')
            .replaceAll("'", '&#39;');
        }

        function formatTime(iso) {
          if (!iso) {
            return '-';
          }
          const date = new Date(iso);
          if (Number.isNaN(date.getTime())) {
            return '-';
          }
          return date.toLocaleTimeString('ko-KR', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
          });
        }

        function handleAuthRequired(message = '로그인이 필요합니다.') {
          state.auth.user = null;
          updateSignedInUser(null);
          showAuthGate(message, 'info');
        }

        async function requestJson(url, options = {}) {
          const {
            suppressAuthRedirect = false,
            ...fetchOptions
          } = options || {};
          const response = await fetch(url, {
            credentials: 'same-origin',
            ...fetchOptions,
          });
          const text = await response.text();
          let data = {};
          try {
            data = text ? JSON.parse(text) : {};
          } catch {
            data = {};
          }

          if (!response.ok) {
            const message = data.message || data.error || `request failed: ${response.status}`;
            const error = new Error(message);
            error.status = response.status;
            error.payload = data;
            if (response.status === 401 && !suppressAuthRedirect) {
              handleAuthRequired(message);
            }
            throw error;
          }

          return data;
        }

        function setNotice(el, message, type = 'info') {
          if (!el) {
            return;
          }
          const styles = {
            info: 'border-sky-200 bg-sky-50 text-sky-800',
            success: 'border-emerald-200 bg-emerald-50 text-emerald-800',
            error: 'border-rose-200 bg-rose-50 text-rose-800',
          };
          el.className = `mt-4 rounded-xl border px-3 py-2 text-sm ${styles[type] || styles.info}`;
          el.textContent = message;
          el.classList.remove('hidden');
        }

        function clearNotice(el) {
          if (!el) {
            return;
          }
          el.textContent = '';
          el.classList.add('hidden');
        }

        function setAuthNotice(message, type = 'info') {
          if (!auth.notice) {
            return;
          }
          const styles = {
            info: 'border-sky-200 bg-sky-50 text-sky-800',
            success: 'border-emerald-200 bg-emerald-50 text-emerald-800',
            error: 'border-rose-200 bg-rose-50 text-rose-800',
          };
          auth.notice.className = `mt-4 rounded-xl border px-3 py-2 text-sm ${styles[type] || styles.info}`;
          auth.notice.textContent = message;
        }

        function updateSignedInUser(user) {
          if (!auth.signedInUser) {
            return;
          }
          if (!user) {
            auth.signedInUser.textContent = '-';
            return;
          }
          const name = String(user.name || user.email || 'User');
          const role = String(user.role || 'viewer');
          auth.signedInUser.textContent = `${name} (${role})`;
        }

        function setAuthFormBusy(isBusy) {
          state.auth.loginBusy = Boolean(isBusy);
          const now = Date.now();
          const lockRemainingSec = Math.max(0, Math.ceil((state.auth.lockUntilMs - now) / 1000));
          const isLocked = lockRemainingSec > 0;

          if (auth.submitBtn) {
            auth.submitBtn.disabled = Boolean(isBusy) || isLocked;
            auth.submitBtn.classList.toggle('opacity-60', Boolean(isBusy) || isLocked);
            auth.submitBtn.textContent = isBusy
              ? '로그인 중...'
              : isLocked
                ? `잠금 ${lockRemainingSec}s`
                : '로그인';
          }
          if (auth.email) {
            auth.email.disabled = isBusy;
          }
          if (auth.password) {
            auth.password.disabled = isBusy;
          }
        }

        function showAppShell() {
          appShell?.classList.remove('hidden');
          auth.gate?.classList.add('hidden');
        }

        function showAuthGate(message = '로그인이 필요합니다.', type = 'info') {
          setAuthNotice(message, type);
          auth.gate?.classList.remove('hidden');
          appShell?.classList.add('hidden');
          stopPolling();
          setAuthFormBusy(state.auth.loginBusy);
        }

        function stopLoginLockTimer() {
          if (!state.auth.lockTimer) {
            return;
          }
          clearInterval(state.auth.lockTimer);
          state.auth.lockTimer = null;
        }

        function clearLoginLockState() {
          state.auth.lockUntilMs = 0;
          stopLoginLockTimer();
          setAuthFormBusy(state.auth.loginBusy);
        }

        function startLoginLockState(retryAfterSec, maxAttempts) {
          const safeRetryAfterSec = Math.max(1, Number(retryAfterSec) || 1);
          state.auth.lockUntilMs = Date.now() + safeRetryAfterSec * 1000;
          stopLoginLockTimer();
          setAuthFormBusy(state.auth.loginBusy);

          const updateLockMessage = () => {
            const remainingSec = Math.max(
              0,
              Math.ceil((state.auth.lockUntilMs - Date.now()) / 1000)
            );
            if (remainingSec <= 0) {
              clearLoginLockState();
              setAuthNotice('로그인을 다시 시도할 수 있습니다.', 'info');
              return;
            }
            const attemptsText = Number.isFinite(Number(maxAttempts))
              ? `최대 ${Number(maxAttempts)}회 초과`
              : '로그인 시도 초과';
            setAuthNotice(`${attemptsText}로 ${remainingSec}초 동안 잠금 상태입니다.`, 'error');
            setAuthFormBusy(state.auth.loginBusy);
          };

          updateLockMessage();
          state.auth.lockTimer = setInterval(updateLockMessage, 1000);
        }

        function parseCsvLine(value) {
          return String(value || '')
            .split(',')
            .map((entry) => entry.trim())
            .filter(Boolean);
        }

        function truncateForDisplay(value, maxLength = 96) {
          const text = String(value || '');
          if (text.length <= maxLength) {
            return text;
          }
          return `${text.slice(0, Math.max(0, maxLength - 3))}...`;
        }

        const state = {
          auth: {
            user: null,
            loginBusy: false,
            lockUntilMs: 0,
            lockTimer: null,
          },
          ui: {
            avatarLoading: false,
          },
          agents: [],
          skills: [],
          selectedAvatar: null,
          providerAuth: {
            providers: [],
            models: [
              {
                value: 'Balanced (default)',
                label: 'Balanced (default)',
                provider: 'system',
                modelId: 'Balanced (default)',
                source: 'builtin',
              },
            ],
            activeAuthProviderId: null,
            oauthChallenges: {},
            oauthCompleting: {},
            lastAutoCallbackUrl: '',
          },
          dataProcessing: {
            features: [],
            lastFileName: '',
            logs: ['[system] help, status, list features, clear features'],
            preview: {
              fileName: '',
              columns: [],
              rows: [],
              totalRows: 0,
              totalColumns: 0,
            },
          },
          deploymentStudio: {
            nodes: [],
            edges: [],
            logs: ['[system] help, list nodes, list edges, connect node-1 node-2, clear'],
            connectMode: false,
            pendingFromNodeId: null,
            selectedNodeId: null,
            nextNodeSeq: 1,
            zoom: 1,
          },
        };

        const dp = {
          notice: document.getElementById('dpNotice'),
          fileInput: document.getElementById('dpHiddenFileInput'),
          uploadWrap: document.getElementById('dpUploadWrap'),
          dropZone: document.getElementById('dpDropZone'),
          pickFileBtn: document.getElementById('dpPickFileBtn'),
          fileMeta: document.getElementById('dpFileMeta'),
          previewWrap: document.getElementById('dpPreviewWrap'),
          previewMeta: document.getElementById('dpPreviewMeta'),
          previewHead: document.getElementById('dpPreviewHead'),
          previewBody: document.getElementById('dpPreviewBody'),
          previewEmpty: document.getElementById('dpPreviewEmpty'),
          resetUploadBtn: document.getElementById('dpResetUploadBtn'),
          featureList: document.getElementById('dpFeatureList'),
          featureEmpty: document.getElementById('dpFeatureEmpty'),
          commandLog: document.getElementById('dpCommandLog'),
          commandForm: document.getElementById('dpCommandForm'),
          commandInput: document.getElementById('dpCommandInput'),
        };

        const ac = {
          notice: document.getElementById('acNotice'),
          name: document.getElementById('acName'),
          modelSelect: document.getElementById('acModelSelect'),
          prompt: document.getElementById('acPrompt'),
          skillList: document.getElementById('acSkillList'),
          clearSkillsBtn: document.getElementById('acClearSkillsBtn'),
          avatarImage: document.getElementById('acAvatarImage'),
          avatarEmpty: document.getElementById('acAvatarEmpty'),
          avatarLoading: document.getElementById('acAvatarLoading'),
          rerollAvatarBtn: document.getElementById('acRerollAvatarBtn'),
          createBtn: document.getElementById('acCreateBtn'),
          list: document.getElementById('acAgentList'),
        };

        const ap = {
          notice: document.getElementById('apNotice'),
          providerList: document.getElementById('apProviderList'),
        };

        const ad = {
          notice: document.getElementById('adNotice'),
          canvas: document.getElementById('adCanvas'),
          stage: document.getElementById('adStage'),
          edgeLayer: document.getElementById('adEdgeLayer'),
          nodeLayer: document.getElementById('adNodeLayer'),
          canvasEmpty: document.getElementById('adCanvasEmpty'),
          connectModeBtn: document.getElementById('adConnectModeBtn'),
          clearCanvasBtn: document.getElementById('adClearCanvasBtn'),
          zoomOutBtn: document.getElementById('adZoomOutBtn'),
          zoomInBtn: document.getElementById('adZoomInBtn'),
          zoomResetBtn: document.getElementById('adZoomResetBtn'),
          zoomLabel: document.getElementById('adZoomLabel'),
          edgeList: document.getElementById('adEdgeList'),
          featurePool: document.getElementById('adFeaturePool'),
          featurePoolEmpty: document.getElementById('adFeaturePoolEmpty'),
          selectedNodeMeta: document.getElementById('adSelectedNodeMeta'),
          nodeFeatureList: document.getElementById('adNodeFeatureList'),
          nodeFeatureEmpty: document.getElementById('adNodeFeatureEmpty'),
          assignAllNodeFeaturesBtn: document.getElementById('adAssignAllNodeFeaturesBtn'),
          clearNodeFeaturesBtn: document.getElementById('adClearNodeFeaturesBtn'),
          agentSourceList: document.getElementById('adAgentSourceList'),
          commandLog: document.getElementById('adCommandLog'),
          commandForm: document.getElementById('adCommandForm'),
          commandInput: document.getElementById('adCommandInput'),
        };

        let refreshingData = false;
        let refreshingAgents = false;
        let refreshingProviderAuth = false;
        let refreshingModelCatalog = false;
        let pollTimer = null;

        function getStatusBadge(status) {
          const map = {
            pending: {
              label: '대기',
              className: 'bg-sky-100 text-sky-700',
            },
            running: {
              label: '실행중',
              className: 'bg-amber-100 text-amber-700',
            },
            completed: {
              label: '완료',
              className: 'bg-emerald-100 text-emerald-700',
            },
            failed: {
              label: '실패',
              className: 'bg-rose-100 text-rose-700',
            },
            standby: {
              label: '대기',
              className: 'bg-slate-100 text-slate-700',
            },
          };
          return (
            map[status] || {
              label: status || 'unknown',
              className: 'bg-slate-100 text-slate-700',
            }
          );
        }

        function setActionButtonsDisabled(isLoading) {
          [
            dp.pickFileBtn,
            ac.clearSkillsBtn,
            ac.rerollAvatarBtn,
            ac.createBtn,
          ].forEach((button) => {
            if (!button) {
              return;
            }
            button.disabled = isLoading;
            button.classList.toggle('opacity-60', isLoading);
          });
        }

        function getSelectedSkills() {
          return Array.from(ac.skillList?.querySelectorAll('input[data-skill]:checked') || [])
            .map((input) => input.dataset.skill)
            .filter(Boolean);
        }

        function renderSkillCatalog(skills) {
          if (!ac.skillList) {
            return;
          }

          if (!Array.isArray(skills) || skills.length === 0) {
            ac.skillList.innerHTML =
              '<p class="rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-500 sm:col-span-2">표시할 스킬이 없습니다.</p>';
            return;
          }

          const selected = new Set(getSelectedSkills());
          ac.skillList.innerHTML = skills
            .map((skill) => {
              const id = String(skill.id || '').trim();
              const label = String(skill.label || id || '').trim();
              const checked = selected.has(id) ? 'checked' : '';

              return `
                <label class="flex items-center gap-2 rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm text-slate-700">
                  <input data-skill="${escapeHtml(id)}" type="checkbox" ${checked} class="h-4 w-4 rounded border-slate-300 text-electric focus:ring-electric" />
                  <span class="truncate">${escapeHtml(label || id)}</span>
                </label>
              `;
            })
            .join('');
        }

        function clearSelectedSkills() {
          const checkedInputs = Array.from(ac.skillList?.querySelectorAll('input[data-skill]:checked') || []);
          for (const input of checkedInputs) {
            input.checked = false;
          }
        }

        function renderSelectedAvatar(avatar) {
          state.selectedAvatar = avatar && avatar.url ? avatar : null;
          if (!ac.avatarImage || !ac.avatarEmpty) {
            return;
          }

          if (!state.selectedAvatar) {
            ac.avatarImage.removeAttribute('src');
            ac.avatarImage.classList.add('hidden');
            ac.avatarEmpty.classList.remove('hidden');
            ac.avatarEmpty.textContent = '사용 가능한 아바타가 없습니다.';
            return;
          }

          ac.avatarImage.src = state.selectedAvatar.url;
          ac.avatarImage.classList.remove('hidden');
          ac.avatarEmpty.classList.add('hidden');
        }

        function wait(ms) {
          return new Promise((resolve) => {
            setTimeout(resolve, Math.max(0, Number(ms) || 0));
          });
        }

        function setAvatarLoading(isLoading) {
          state.ui.avatarLoading = Boolean(isLoading);

          if (ac.avatarLoading) {
            ac.avatarLoading.classList.toggle('hidden', !isLoading);
            ac.avatarLoading.classList.toggle('flex', Boolean(isLoading));
          }

          if (ac.rerollAvatarBtn) {
            ac.rerollAvatarBtn.disabled = Boolean(isLoading);
            ac.rerollAvatarBtn.classList.toggle('opacity-60', Boolean(isLoading));
            ac.rerollAvatarBtn.textContent = isLoading ? '뽑는 중...' : 'avatars 다시 뽑기';
          }
        }

        function preloadImage(url, timeoutMs = 8000) {
          return new Promise((resolve) => {
            const targetUrl = String(url || '').trim();
            if (!targetUrl) {
              resolve(false);
              return;
            }

            const image = new Image();
            let finished = false;
            const finish = (ok) => {
              if (finished) {
                return;
              }
              finished = true;
              clearTimeout(timer);
              image.onload = null;
              image.onerror = null;
              resolve(Boolean(ok));
            };

            const timer = setTimeout(() => finish(false), Math.max(500, Number(timeoutMs) || 8000));
            image.onload = () => finish(true);
            image.onerror = () => finish(false);
            image.decoding = 'async';
            image.src = targetUrl;
          });
        }

        function canManageProviderAuth() {
          const role = String(state.auth.user?.role || '').trim().toLowerCase();
          return role === 'owner' || role === 'admin';
        }

        function getProviderStatusMeta(statusRaw) {
          const status = String(statusRaw || '').trim().toLowerCase();
          if (status === 'connected') {
            return {
              label: '인증 완료',
              className: 'border-emerald-200 bg-emerald-100 text-emerald-800',
            };
          }
          if (status === 'error') {
            return {
              label: '인증 실패',
              className: 'border-rose-200 bg-rose-100 text-rose-800',
            };
          }
          return {
            label: '미인증',
            className: 'border-slate-200 bg-slate-100 text-slate-700',
          };
        }

        function renderAgentModelCatalog() {
          if (!ac.modelSelect) {
            return;
          }

          const fallbackModel = [
            {
              value: 'Balanced (default)',
              label: 'Balanced (default)',
              provider: 'system',
            },
          ];
          const models = Array.isArray(state.providerAuth.models) && state.providerAuth.models.length > 0
            ? state.providerAuth.models
            : fallbackModel;
          const previousValue = String(ac.modelSelect.value || '').trim();
          ac.modelSelect.innerHTML = models
            .map((item) => {
              const value = String(item.value || '').trim();
              const label = String(item.label || value || '').trim() || value;
              const provider = String(item.provider || '').trim();
              const sourceLabel = provider && provider !== 'system' ? ` (${provider})` : '';
              return `<option value="${escapeHtml(value)}">${escapeHtml(`${label}${sourceLabel}`)}</option>`;
            })
            .join('');

          const hasPreviousValue = models.some((item) => String(item.value || '').trim() === previousValue);
          if (hasPreviousValue) {
            ac.modelSelect.value = previousValue;
            return;
          }
          if (models.length > 0) {
            ac.modelSelect.value = String(models[0].value || 'Balanced (default)');
          }
        }

        function renderProviderAuthList() {
          if (!ap.providerList) {
            return;
          }

          const providers = Array.isArray(state.providerAuth.providers)
            ? state.providerAuth.providers
            : [];
          const canManage = canManageProviderAuth();
          const disabledClass = canManage ? '' : 'cursor-not-allowed opacity-60';
          const disabledAttr = canManage ? '' : 'disabled';
          const activeProviderId = String(state.providerAuth.activeAuthProviderId || '');

          if (providers.length === 0) {
            ap.providerList.innerHTML =
              '<li class="rounded-xl border border-slate-200 bg-white p-3 text-slate-500">등록된 인증 항목이 없습니다.</li>';
            return;
          }

          ap.providerList.innerHTML = providers
            .map((provider) => {
              const statusMeta = getProviderStatusMeta(provider.status);
              const providerId = String(provider.id || '').trim();
              const displayName = String(provider.displayName || provider.provider || '').trim() || '-';
              const modelCount = Math.max(0, Number(provider.modelCount) || 0);
              const errorMessage = String(provider.errorMessage || '').trim();
              const isActive = providerId === activeProviderId;
              const authMode = String(provider.authMode || 'api_key').trim().toLowerCase();
              const isOauthMode = authMode === 'oauth';
              const actionLabel = provider.status === 'connected' ? '재인증' : 'Auth 인증하기';
              const oauthState = state.providerAuth.oauthChallenges?.[providerId] || null;
              const oauthExpiresAt = String(oauthState?.expiresAt || '').trim();
              const oauthExpiresDate = oauthExpiresAt ? new Date(oauthExpiresAt) : null;
              const oauthExpiresText =
                oauthExpiresDate && !Number.isNaN(oauthExpiresDate.getTime())
                  ? oauthExpiresDate.toLocaleString('ko-KR')
                  : '';

              return `
                <li class="rounded-xl border border-slate-200 bg-white p-3">
                  <div class="flex flex-wrap items-center justify-between gap-2">
                    <div class="min-w-0">
                      <p class="font-semibold text-slate-900">${escapeHtml(displayName)}</p>
                      <p class="mt-1 text-xs text-slate-500">provider: ${escapeHtml(provider.provider || '-')} · 인증: ${escapeHtml(authMode)} · 모델 ${escapeHtml(String(modelCount))}개</p>
                    </div>
                    <div class="flex items-center gap-2">
                      <span class="rounded-lg border px-2 py-1 text-xs font-semibold ${statusMeta.className}">${statusMeta.label}</span>
                      <button
                        type="button"
                        data-action="open-auth"
                        data-provider-id="${escapeHtml(providerId)}"
                        class="rounded-lg border border-slate-200 bg-white px-2.5 py-1.5 text-xs font-semibold text-slate-700 transition hover:bg-slate-100 ${disabledClass}"
                        ${disabledAttr}
                      >
                        ${actionLabel}
                      </button>
                      <button
                        type="button"
                        data-action="disconnect-provider"
                        data-provider-id="${escapeHtml(providerId)}"
                        class="rounded-lg border border-slate-200 bg-white px-2.5 py-1.5 text-xs font-semibold text-slate-700 transition hover:bg-slate-100 ${disabledClass}"
                        ${disabledAttr}
                      >
                        연결 해제
                      </button>
                    </div>
                  </div>
                  ${errorMessage ? `<p class="mt-2 text-xs text-rose-600">${escapeHtml(errorMessage)}</p>` : ''}
                  ${
                    isActive
                      ? `
                    <form data-auth-form="true" data-provider-id="${escapeHtml(providerId)}" data-auth-mode="${escapeHtml(authMode)}" class="mt-3 rounded-xl border border-slate-200 bg-slate-50 p-3">
                      ${
                        isOauthMode
                          ? `
                        <p class="text-xs text-slate-600">
                          브라우저 인증 후 리다이렉트 URL 전체(또는 code)를 붙여넣어 완료하세요.
                        </p>
                        <div class="mt-2 flex flex-wrap items-center justify-between gap-2">
                          <button
                            type="button"
                            data-action="start-oauth"
                            data-provider-id="${escapeHtml(providerId)}"
                            class="rounded-lg border border-slate-200 bg-white px-3 py-1.5 text-xs font-semibold text-slate-700 transition hover:bg-slate-100 ${disabledClass}"
                            ${disabledAttr}
                          >
                            인증 URL 열기
                          </button>
                          ${
                            oauthState?.challengeToken
                              ? `<span class="text-[11px] text-slate-500">유효시간: ${escapeHtml(oauthExpiresText || '-')}</span>`
                              : '<span class="text-[11px] text-slate-500">인증 URL을 먼저 열어주세요.</span>'
                          }
                        </div>
                        <label class="mt-3 block text-sm">
                          <span class="mb-1 block text-xs uppercase tracking-wide text-slate-500">Callback URL or Code</span>
                          <input
                            name="callbackInput"
                            type="text"
                            autocomplete="off"
                            placeholder="http://localhost:1455/auth/callback?code=...&state=... 또는 code"
                            class="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm outline-none ring-electric/30 transition focus:ring"
                            required
                          />
                        </label>
                      `
                          : `
                        <label class="block text-sm">
                          <span class="mb-1 block text-xs uppercase tracking-wide text-slate-500">API Key</span>
                          <input
                            name="apiKey"
                            type="password"
                            autocomplete="off"
                            placeholder="AIza..., 등"
                            class="w-full rounded-xl border border-slate-200 bg-white px-3 py-2 text-sm outline-none ring-electric/30 transition focus:ring"
                            required
                          />
                        </label>
                      `
                      }
                      <div class="mt-3 flex flex-wrap items-center justify-end gap-2">
                        <button
                          type="button"
                          data-action="cancel-auth"
                          data-provider-id="${escapeHtml(providerId)}"
                          class="rounded-lg border border-slate-200 bg-white px-3 py-1.5 text-xs font-semibold text-slate-700 transition hover:bg-slate-100 ${disabledClass}"
                          ${disabledAttr}
                        >
                          취소
                        </button>
                        <button
                          type="submit"
                          class="rounded-lg bg-ink px-3 py-1.5 text-xs font-semibold text-white transition hover:bg-slate-800 ${disabledClass}"
                          ${disabledAttr}
                        >
                          인증 저장
                        </button>
                      </div>
                    </form>
                  `
                      : ''
                  }
                </li>
              `;
            })
            .join('');
        }

        function findProviderConnection(providerId) {
          const normalizedProviderId = String(providerId || '').trim();
          if (!normalizedProviderId) {
            return null;
          }
          return (
            (Array.isArray(state.providerAuth.providers) ? state.providerAuth.providers : []).find(
              (item) => String(item?.id || '').trim() === normalizedProviderId
            ) || null
          );
        }

        function clearProviderOAuthState(providerId) {
          const normalizedProviderId = String(providerId || '').trim();
          if (!normalizedProviderId) {
            return;
          }
          if (!state.providerAuth.oauthChallenges || typeof state.providerAuth.oauthChallenges !== 'object') {
            state.providerAuth.oauthChallenges = {};
          }
          delete state.providerAuth.oauthChallenges[normalizedProviderId];
        }

        function parseOAuthStateFromCallbackInput(input) {
          const value = String(input || '').trim();
          if (!value) {
            return '';
          }

          try {
            const parsed = new URL(value);
            return String(parsed.searchParams.get('state') || '').trim();
          } catch {
            // not a full URL
          }

          if (value.includes('state=')) {
            const params = new URLSearchParams(value);
            return String(params.get('state') || '').trim();
          }

          return '';
        }

        function resolveProviderIdFromOAuthState(callbackState) {
          const targetState = String(callbackState || '').trim();
          if (!targetState) {
            return '';
          }
          const entries = Object.entries(state.providerAuth.oauthChallenges || {});
          for (const [providerId, challenge] of entries) {
            const challengeState = String(challenge?.state || '').trim();
            if (challengeState && challengeState === targetState) {
              return String(providerId || '').trim();
            }
          }
          return '';
        }

        function resolvePendingOAuthProviderId(callbackInput) {
          const stateFromCallback = parseOAuthStateFromCallbackInput(callbackInput);
          const byState = resolveProviderIdFromOAuthState(stateFromCallback);
          if (byState) {
            return byState;
          }

          const activeProviderId = String(state.providerAuth.activeAuthProviderId || '').trim();
          if (activeProviderId && state.providerAuth.oauthChallenges?.[activeProviderId]) {
            return activeProviderId;
          }

          const pendingProviderIds = Object.keys(state.providerAuth.oauthChallenges || {});
          if (pendingProviderIds.length === 1) {
            return String(pendingProviderIds[0] || '').trim();
          }

          return '';
        }

        async function refreshProviderAuth() {
          if (refreshingProviderAuth) {
            return;
          }
          refreshingProviderAuth = true;
          try {
            const response = await requestJson('/api/provider-auth');
            state.providerAuth.providers = Array.isArray(response.providers) ? response.providers : [];
            const providerIdSet = new Set(
              state.providerAuth.providers.map((item) => String(item?.id || '').trim()).filter(Boolean)
            );
            if (!providerIdSet.has(String(state.providerAuth.activeAuthProviderId || '').trim())) {
              state.providerAuth.activeAuthProviderId = null;
            }
            const oauthChallenges = state.providerAuth.oauthChallenges || {};
            for (const providerId of Object.keys(oauthChallenges)) {
              if (!providerIdSet.has(providerId)) {
                delete oauthChallenges[providerId];
              }
            }
            renderProviderAuthList();
          } catch (error) {
            state.providerAuth.providers = [];
            renderProviderAuthList();
            setNotice(ap.notice, `인증 항목 조회 실패: ${error.message}`, 'error');
          } finally {
            refreshingProviderAuth = false;
          }
        }

        async function refreshModelCatalog() {
          if (refreshingModelCatalog) {
            return;
          }
          refreshingModelCatalog = true;
          try {
            const response = await requestJson('/api/models');
            state.providerAuth.models = Array.isArray(response.models) ? response.models : [];
            renderAgentModelCatalog();
          } catch (error) {
            state.providerAuth.models = [
              {
                value: 'Balanced (default)',
                label: 'Balanced (default)',
                provider: 'system',
                modelId: 'Balanced (default)',
                source: 'builtin',
              },
            ];
            renderAgentModelCatalog();
            setNotice(ac.notice, `모델 목록 조회 실패: ${error.message}`, 'error');
          } finally {
            refreshingModelCatalog = false;
          }
        }

        async function startProviderOAuth(providerId, options = {}) {
          const normalizedProviderId = String(providerId || '').trim();
          if (!normalizedProviderId) {
            return;
          }

          const openWindow = options.openWindow !== false;
          try {
            const response = await requestJson(`/api/provider-auth/${encodeURIComponent(normalizedProviderId)}/oauth/start`, {
              method: 'POST',
            });
            const oauth = response?.oauth || {};
            const authorizeUrl = String(oauth.authorizeUrl || '').trim();
            const challengeToken = String(oauth.challengeToken || '').trim();
            const expiresAt = String(oauth.expiresAt || '').trim();
            const challengeState = String(oauth.state || '').trim();
            if (!authorizeUrl || !challengeToken) {
              throw new Error('OAuth 인증 URL 생성에 실패했습니다.');
            }

            if (!state.providerAuth.oauthChallenges || typeof state.providerAuth.oauthChallenges !== 'object') {
              state.providerAuth.oauthChallenges = {};
            }
            state.providerAuth.oauthChallenges[normalizedProviderId] = {
              authorizeUrl,
              challengeToken,
              expiresAt,
              state: challengeState,
            };

            renderProviderAuthList();

            if (openWindow) {
              const opened = window.open(authorizeUrl, '_blank');
              if (!opened) {
                setNotice(
                  ap.notice,
                  '팝업이 차단되었습니다. 브라우저에서 팝업 허용 후 다시 시도하거나, URL을 새 탭에서 직접 열어주세요.',
                  'info'
                );
              }
            }

            setNotice(
              ap.notice,
              '브라우저 인증 완료 후 자동으로 처리됩니다. 자동 실패 시 callback URL을 수동으로 붙여넣어 완료하세요.',
              'info'
            );
          } catch (error) {
            setNotice(ap.notice, `OAuth 시작 실패: ${error.message}`, 'error');
          }
        }

        async function completeProviderOAuth(providerId, callbackInput) {
          const normalizedProviderId = String(providerId || '').trim();
          const normalizedCallbackInput = String(callbackInput || '').trim();
          if (!normalizedProviderId || !normalizedCallbackInput) {
            setNotice(ap.notice, 'callback URL 또는 code를 입력하세요.', 'error');
            return;
          }

          if (!state.providerAuth.oauthCompleting || typeof state.providerAuth.oauthCompleting !== 'object') {
            state.providerAuth.oauthCompleting = {};
          }
          if (state.providerAuth.oauthCompleting[normalizedProviderId]) {
            return;
          }
          state.providerAuth.oauthCompleting[normalizedProviderId] = true;

          const oauthState = state.providerAuth.oauthChallenges?.[normalizedProviderId] || null;
          const challengeToken = String(oauthState?.challengeToken || '').trim();
          if (!challengeToken) {
            state.providerAuth.oauthCompleting[normalizedProviderId] = false;
            setNotice(ap.notice, '먼저 인증 URL 열기를 실행하세요.', 'error');
            return;
          }

          try {
            const response = await requestJson(
              `/api/provider-auth/${encodeURIComponent(normalizedProviderId)}/oauth/complete`,
              {
                method: 'POST',
                headers: { 'content-type': 'application/json' },
                body: JSON.stringify({
                  challengeToken,
                  callbackInput: normalizedCallbackInput,
                }),
              }
            );
            clearProviderOAuthState(normalizedProviderId);
            state.providerAuth.activeAuthProviderId = null;
            await Promise.all([refreshProviderAuth(), refreshModelCatalog()]);
            const providerName = response?.provider?.displayName || 'provider';
            const modelCount = Number(response?.verifiedModels || 0);
            setNotice(ap.notice, `${providerName} OAuth 인증 완료 (모델 ${modelCount}개 확인)`, 'success');
          } catch (error) {
            setNotice(ap.notice, `OAuth 인증 실패: ${error.message}`, 'error');
          } finally {
            state.providerAuth.oauthCompleting[normalizedProviderId] = false;
          }
        }

        async function handleOAuthPopupCallback(callbackUrl) {
          const normalizedCallbackUrl = String(callbackUrl || '').trim();
          if (!normalizedCallbackUrl) {
            return;
          }
          if (state.providerAuth.lastAutoCallbackUrl === normalizedCallbackUrl) {
            return;
          }
          state.providerAuth.lastAutoCallbackUrl = normalizedCallbackUrl;

          const providerId = resolvePendingOAuthProviderId(normalizedCallbackUrl);
          if (!providerId) {
            setNotice(
              ap.notice,
              '자동 OAuth 매칭에 실패했습니다. callback URL을 입력 칸에 붙여넣어 인증 저장을 눌러주세요.',
              'info'
            );
            return;
          }

          await completeProviderOAuth(providerId, normalizedCallbackUrl);
        }

        async function handleOAuthAutoCompletePayload(payload = {}) {
          const ok = Boolean(payload?.ok);
          const providerId = String(payload?.providerId || '').trim();
          const providerName = String(payload?.providerName || 'OPEN AI').trim() || 'OPEN AI';
          const callbackUrl = String(payload?.callbackUrl || '').trim();
          const errorMessage = String(payload?.errorMessage || '').trim();

          if (providerId) {
            clearProviderOAuthState(providerId);
          }

          if (ok) {
            state.providerAuth.activeAuthProviderId = null;
            await Promise.all([refreshProviderAuth(), refreshModelCatalog()]);
            const modelCount = Math.max(0, Number(payload?.verifiedModels || 0));
            setNotice(ap.notice, `${providerName} OAuth 자동 인증 완료 (모델 ${modelCount}개 확인)`, 'success');
            return;
          }

          if (callbackUrl) {
            const providerIdFromCallback = resolvePendingOAuthProviderId(callbackUrl);
            if (providerIdFromCallback) {
              await completeProviderOAuth(providerIdFromCallback, callbackUrl);
              return;
            }
          }

          setNotice(
            ap.notice,
            errorMessage || 'OAuth 자동 인증이 실패했습니다. callback URL을 붙여넣어 수동 완료해주세요.',
            'error'
          );
        }

        async function authenticateProviderConnection(providerId, apiKey) {
          const normalizedProviderId = String(providerId || '').trim();
          const normalizedApiKey = String(apiKey || '').trim();
          if (!normalizedProviderId || !normalizedApiKey) {
            setNotice(ap.notice, 'provider와 API Key를 모두 입력하세요.', 'error');
            return;
          }

          try {
            const response = await requestJson(`/api/provider-auth/${encodeURIComponent(normalizedProviderId)}/authenticate`, {
              method: 'POST',
              headers: { 'content-type': 'application/json' },
              body: JSON.stringify({
                apiKey: normalizedApiKey,
              }),
            });
            state.providerAuth.activeAuthProviderId = null;
            await Promise.all([refreshProviderAuth(), refreshModelCatalog()]);
            const providerName = response?.provider?.displayName || 'provider';
            const modelCount = Number(response?.verifiedModels || 0);
            setNotice(ap.notice, `${providerName} 인증 완료 (모델 ${modelCount}개 확인)`, 'success');
          } catch (error) {
            setNotice(ap.notice, `인증 실패: ${error.message}`, 'error');
          }
        }

        async function disconnectProviderConnection(providerId) {
          const normalizedProviderId = String(providerId || '').trim();
          if (!normalizedProviderId) {
            return;
          }

          try {
            await requestJson(`/api/provider-auth/${encodeURIComponent(normalizedProviderId)}/disconnect`, {
              method: 'POST',
            });
            clearProviderOAuthState(normalizedProviderId);
            state.providerAuth.activeAuthProviderId = null;
            await Promise.all([refreshProviderAuth(), refreshModelCatalog()]);
            setNotice(ap.notice, '연결이 해제되었습니다.', 'info');
          } catch (error) {
            setNotice(ap.notice, `연결 해제 실패: ${error.message}`, 'error');
          }
        }

        function initializeProviderAuthPanel() {
          renderProviderAuthList();
          renderAgentModelCatalog();

          window.addEventListener('message', async (event) => {
            const payload = event?.data;
            if (!payload || typeof payload !== 'object') {
              return;
            }
            const messageType = String(payload.type || '').trim();
            if (!messageType) {
              return;
            }

            if (messageType === 'provider-oauth-complete') {
              await handleOAuthAutoCompletePayload(payload);
              return;
            }

            if (messageType === 'provider-oauth-callback') {
              const callbackUrl = String(payload.callbackUrl || '').trim();
              if (!callbackUrl) {
                return;
              }
              await handleOAuthPopupCallback(callbackUrl);
            }
          });

          ap.providerList?.addEventListener('click', async (event) => {
            const targetButton = event.target.closest('button[data-action]');
            if (!targetButton) {
              return;
            }

            const action = String(targetButton.dataset.action || '');
            const providerId = String(targetButton.dataset.providerId || '').trim();
            if (!providerId) {
              return;
            }

            if (action === 'open-auth') {
              state.providerAuth.activeAuthProviderId = providerId;
              renderProviderAuthList();
              const provider = findProviderConnection(providerId);
              const authMode = String(provider?.authMode || '').trim().toLowerCase();
              if (authMode === 'oauth') {
                await startProviderOAuth(providerId, { openWindow: true });
              }
              return;
            }
            if (action === 'cancel-auth') {
              state.providerAuth.activeAuthProviderId = null;
              renderProviderAuthList();
              return;
            }
            if (action === 'start-oauth') {
              await startProviderOAuth(providerId, { openWindow: true });
              return;
            }
            if (action === 'disconnect-provider') {
              await disconnectProviderConnection(providerId);
            }
          });

          ap.providerList?.addEventListener('submit', async (event) => {
            const form = event.target.closest('form[data-auth-form="true"]');
            if (!form) {
              return;
            }
            event.preventDefault();
            const providerId = String(form.dataset.providerId || '').trim();
            const authMode = String(form.dataset.authMode || 'api_key').trim().toLowerCase();
            if (authMode === 'oauth') {
              const input = form.querySelector('input[name="callbackInput"]');
              const callbackInput = String(input?.value || '').trim();
              await completeProviderOAuth(providerId, callbackInput);
              if (input) {
                input.value = '';
              }
              return;
            }

            const apiKeyInput = form.querySelector('input[name="apiKey"]');
            const apiKey = String(apiKeyInput?.value || '').trim();
            await authenticateProviderConnection(providerId, apiKey);
            if (apiKeyInput) {
              apiKeyInput.value = '';
            }
          });
        }

        function isServerInitializationError(error) {
          const errorCode = String(error?.payload?.error || '')
            .trim()
            .toLowerCase();
          const message = String(error?.message || '')
            .trim()
            .toLowerCase();
          return (
            errorCode === 'bootstrap_failed' ||
            message.includes('server initialization failed')
          );
        }

        function clearAvatarNoticeIfNeeded() {
          if (!ac.notice || ac.notice.classList.contains('hidden')) {
            return;
          }
          const text = String(ac.notice.textContent || '');
          if (
            text.startsWith('아바타 로드 실패:') ||
            text.includes('서버 초기화 중입니다')
          ) {
            clearNotice(ac.notice);
          }
        }

        async function fetchRandomAvatarWithRetry(maxAttempts = 2) {
          const attempts = Math.max(1, Number(maxAttempts) || 1);
          let lastError = null;

          for (let attempt = 1; attempt <= attempts; attempt += 1) {
            try {
              return await requestJson('/api/avatars/random');
            } catch (error) {
              lastError = error;
              if (!isServerInitializationError(error) || attempt >= attempts) {
                throw error;
              }
              await wait(180 * attempt);
            }
          }

          throw lastError || new Error('avatar request failed');
        }

        function renderDataFeatures() {
          if (!dp.featureList || !dp.featureEmpty) {
            return;
          }

          const features = state.dataProcessing.features;
          if (!Array.isArray(features) || features.length === 0) {
            dp.featureList.innerHTML = '';
            dp.featureEmpty.classList.remove('hidden');
            return;
          }

          dp.featureEmpty.classList.add('hidden');
          dp.featureList.innerHTML = features
            .slice(0, 120)
            .map(
              (feature) =>
                `<span class="rounded-full border border-slate-200 bg-slate-50 px-2 py-1 text-xs font-semibold text-slate-700">${escapeHtml(
                  feature
                )}</span>`
            )
            .join('');
        }

        function resetDataPreview() {
          state.dataProcessing.preview = {
            fileName: '',
            columns: [],
            rows: [],
            totalRows: 0,
            totalColumns: 0,
          };
        }

        function renderDataPreview() {
          if (!dp.uploadWrap || !dp.previewWrap || !dp.previewMeta || !dp.previewHead || !dp.previewBody || !dp.previewEmpty) {
            return;
          }

          const preview = state.dataProcessing.preview || {};
          const columns = Array.isArray(preview.columns) ? preview.columns : [];
          const rows = Array.isArray(preview.rows) ? preview.rows : [];
          const hasPreview = columns.length > 0;

          dp.uploadWrap.classList.toggle('hidden', hasPreview);
          dp.previewWrap.classList.toggle('hidden', !hasPreview);

          if (!hasPreview) {
            dp.previewMeta.textContent = '프리뷰 정보를 준비 중입니다.';
            dp.previewHead.innerHTML = '';
            dp.previewBody.innerHTML = '';
            dp.previewEmpty.classList.remove('hidden');
            return;
          }

          const safeTotalRows = Math.max(0, Number(preview.totalRows) || 0);
          const safeTotalColumns = Math.max(columns.length, Number(preview.totalColumns) || 0);
          const fileName = preview.fileName || state.dataProcessing.lastFileName || '-';
          dp.previewMeta.textContent = `${fileName} · 총 ${safeTotalRows}행 · 컬럼 ${safeTotalColumns}개`;

          dp.previewHead.innerHTML = `
            <tr>
              <th class="w-12 whitespace-nowrap px-3 py-2 font-semibold text-slate-500">#</th>
              ${columns
                .map(
                  (column) =>
                    `<th class="whitespace-nowrap px-3 py-2 font-semibold text-slate-600">${escapeHtml(column)}</th>`
                )
                .join('')}
            </tr>
          `;

          dp.previewBody.innerHTML = rows
            .map((row, rowIndex) => {
              const cells = Array.isArray(row) ? row : [];
              return `
                <tr class="border-t border-slate-100 align-top">
                  <td class="whitespace-nowrap px-3 py-2 text-slate-400">${rowIndex + 1}</td>
                  ${columns
                    .map((_, columnIndex) => {
                      const raw = cells[columnIndex] ?? '';
                      const text = String(raw);
                      return `<td class="px-3 py-2 text-slate-700" title="${escapeHtml(text)}">${escapeHtml(
                        truncateForDisplay(text, 80)
                      )}</td>`;
                    })
                    .join('')}
                </tr>
              `;
            })
            .join('');

          dp.previewEmpty.classList.toggle('hidden', rows.length > 0);
        }

        function resetDataUploadState() {
          state.dataProcessing.lastFileName = '';
          state.dataProcessing.features = [];
          resetDataPreview();
          renderDataFeatures();
          renderDataPreview();
          syncStudioFeaturesFromData();
          if (dp.fileMeta) {
            dp.fileMeta.textContent = '아직 선택된 파일이 없습니다.';
          }
        }

        function getFeaturePool() {
          return Array.isArray(state.dataProcessing.features) ? state.dataProcessing.features : [];
        }

        function normalizeNodeFeatures(features) {
          const pool = new Set(getFeaturePool());
          return [...new Set((features || []).map((feature) => String(feature || '').trim()).filter((feature) => feature && pool.has(feature)))];
        }

        function renderDeploymentFeaturePool() {
          if (!ad.featurePool || !ad.featurePoolEmpty) {
            return;
          }

          const features = getFeaturePool();
          if (features.length === 0) {
            ad.featurePool.innerHTML = '';
            ad.featurePoolEmpty.classList.remove('hidden');
            return;
          }

          ad.featurePoolEmpty.classList.add('hidden');
          ad.featurePool.innerHTML = features
            .slice(0, 200)
            .map(
              (feature) =>
                `<span class="rounded-full border border-sky-200 bg-sky-50 px-2 py-1 text-[11px] font-semibold text-sky-700">${escapeHtml(
                  feature
                )}</span>`
            )
            .join('');
        }

        function syncStudioFeaturesFromData() {
          let changed = false;
          for (const node of state.deploymentStudio.nodes) {
            const nextFeatures = normalizeNodeFeatures(node.features);
            const currentFeatures = Array.isArray(node.features) ? node.features : [];
            if (nextFeatures.length !== currentFeatures.length || nextFeatures.some((value, index) => value !== currentFeatures[index])) {
              node.features = nextFeatures;
              changed = true;
            }
          }

          if (state.deploymentStudio.selectedNodeId && !getNodeById(state.deploymentStudio.selectedNodeId)) {
            state.deploymentStudio.selectedNodeId = null;
          }

          renderDeploymentFeaturePool();
          if (changed) {
            renderStudioNodes();
            return;
          }
          renderNodeFeatureEditor();
        }

        function pushDataLog(message) {
          const now = new Date().toLocaleTimeString('ko-KR', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
          });
          state.dataProcessing.logs.push(`[${now}] ${message}`);
          state.dataProcessing.logs = state.dataProcessing.logs.slice(-250);

          if (dp.commandLog) {
            dp.commandLog.textContent = state.dataProcessing.logs.join('\n');
            dp.commandLog.scrollTop = dp.commandLog.scrollHeight;
          }
        }

        function normalizeColumnName(value, index) {
          const clean = String(value || '').trim().replace(/^['"]|['"]$/g, '');
          return clean || `column_${index + 1}`;
        }

        function toPreviewCellText(value) {
          if (value === null || value === undefined) {
            return '';
          }
          if (typeof value === 'object') {
            try {
              return JSON.stringify(value);
            } catch {
              return '[object]';
            }
          }
          return String(value);
        }

        function parseDelimitedLine(line, delimiter) {
          const text = String(line || '');
          const cells = [];
          let current = '';
          let inQuotes = false;

          for (let index = 0; index < text.length; index += 1) {
            const ch = text[index];
            if (ch === '"') {
              if (inQuotes && text[index + 1] === '"') {
                current += '"';
                index += 1;
              } else {
                inQuotes = !inQuotes;
              }
              continue;
            }

            if (ch === delimiter && !inQuotes) {
              cells.push(current);
              current = '';
              continue;
            }

            current += ch;
          }

          cells.push(current);
          return cells.map((cell) => String(cell || '').trim());
        }

        function buildDelimitedPreview(text, delimiter, options = {}) {
          const maxRows = Math.max(1, Number(options.maxRows) || 20);
          const maxColumns = Math.max(1, Number(options.maxColumns) || 16);
          const lines = String(text || '')
            .split(/\r?\n/)
            .filter((line) => String(line).trim().length > 0);

          if (lines.length === 0) {
            return {
              allColumns: [],
              previewColumns: [],
              previewRows: [],
              totalRows: 0,
            };
          }

          const rawHeaders = parseDelimitedLine(lines[0], delimiter);
          const allColumns = rawHeaders.map((name, index) => normalizeColumnName(name, index));
          const previewColumns = allColumns.slice(0, maxColumns);
          const previewRows = [];

          for (let lineIndex = 1; lineIndex < lines.length && previewRows.length < maxRows; lineIndex += 1) {
            const cells = parseDelimitedLine(lines[lineIndex], delimiter);
            previewRows.push(
              previewColumns.map((_, columnIndex) => toPreviewCellText(cells[columnIndex]))
            );
          }

          return {
            allColumns,
            previewColumns,
            previewRows,
            totalRows: Math.max(0, lines.length - 1),
          };
        }

        function buildJsonPreview(value, options = {}) {
          const maxRows = Math.max(1, Number(options.maxRows) || 20);
          const maxColumns = Math.max(1, Number(options.maxColumns) || 16);

          if (Array.isArray(value)) {
            const objectRows = value.filter((row) => row && typeof row === 'object' && !Array.isArray(row));
            if (objectRows.length === 0) {
              return {
                allColumns: ['value'],
                previewColumns: ['value'],
                previewRows: value.slice(0, maxRows).map((item) => [toPreviewCellText(item)]),
                totalRows: value.length,
              };
            }

            const keySet = new Set();
            for (const row of objectRows.slice(0, 400)) {
              for (const key of Object.keys(row)) {
                const normalized = String(key || '').trim();
                if (normalized) {
                  keySet.add(normalized);
                }
              }
            }

            const allColumns = Array.from(keySet);
            const previewColumns = allColumns.slice(0, maxColumns);
            const previewRows = objectRows.slice(0, maxRows).map((row) =>
              previewColumns.map((column) => toPreviewCellText(row[column]))
            );

            return {
              allColumns,
              previewColumns,
              previewRows,
              totalRows: objectRows.length,
            };
          }

          if (value && typeof value === 'object') {
            const allColumns = Object.keys(value).map((column, index) => normalizeColumnName(column, index));
            const previewColumns = allColumns.slice(0, maxColumns);
            return {
              allColumns,
              previewColumns,
              previewRows: [previewColumns.map((column) => toPreviewCellText(value[column]))],
              totalRows: 1,
            };
          }

          return {
            allColumns: ['value'],
            previewColumns: ['value'],
            previewRows: [[toPreviewCellText(value)]],
            totalRows: value === null || value === undefined ? 0 : 1,
          };
        }

        async function analyzeDroppedDataFile(file) {
          if (!file) {
            return;
          }

          const fileName = file.name || 'unknown';
          state.dataProcessing.lastFileName = fileName;
          if (dp.fileMeta) {
            const sizeKb = Math.max(1, Math.round((file.size || 0) / 1024));
            dp.fileMeta.textContent = `${fileName} (${sizeKb} KB)`;
          }

          const lowerName = fileName.toLowerCase();
          let features = [];
          let previewColumns = [];
          let previewRows = [];
          let totalRows = 0;

          try {
            if (lowerName.endsWith('.csv')) {
              const text = await file.text();
              const preview = buildDelimitedPreview(text, ',', { maxRows: 20, maxColumns: 16 });
              features = preview.allColumns;
              previewColumns = preview.previewColumns;
              previewRows = preview.previewRows;
              totalRows = preview.totalRows;
            } else if (lowerName.endsWith('.tsv') || lowerName.endsWith('.txt')) {
              const text = await file.text();
              const preview = buildDelimitedPreview(text, '\t', { maxRows: 20, maxColumns: 16 });
              features = preview.allColumns;
              previewColumns = preview.previewColumns;
              previewRows = preview.previewRows;
              totalRows = preview.totalRows;
            } else if (lowerName.endsWith('.json')) {
              const text = await file.text();
              const parsed = JSON.parse(text);
              const preview = buildJsonPreview(parsed, { maxRows: 20, maxColumns: 16 });
              features = preview.allColumns;
              previewColumns = preview.previewColumns;
              previewRows = preview.previewRows;
              totalRows = preview.totalRows;
            } else {
              setNotice(dp.notice, '해당 형식은 지금은 feature 미리보기 미지원입니다. (csv/json 우선 지원)', 'info');
              pushDataLog(`분석 대기 형식: ${fileName}`);
              return;
            }
          } catch (error) {
            setNotice(dp.notice, `파일 분석 실패: ${error.message}`, 'error');
            pushDataLog(`분석 실패: ${fileName}`);
            return;
          }

          const uniqueFeatures = [...new Set(features.map((item) => String(item).trim()).filter(Boolean))];
          state.dataProcessing.features = uniqueFeatures;
          state.dataProcessing.preview = {
            fileName,
            columns: previewColumns,
            rows: previewRows,
            totalRows,
            totalColumns: uniqueFeatures.length,
          };
          renderDataFeatures();
          renderDataPreview();
          syncStudioFeaturesFromData();
          setNotice(dp.notice, `feature ${uniqueFeatures.length}개 추출`, 'success');
          pushDataLog(`feature 추출 완료: ${fileName} (${uniqueFeatures.length})`);
        }

        async function handleDataFileSelection(fileList) {
          const file = fileList?.[0];
          if (!file) {
            return;
          }
          await analyzeDroppedDataFile(file);
        }

        function executeDataCommand(commandRaw) {
          const command = String(commandRaw || '').trim();
          if (!command) {
            return;
          }
          pushDataLog(`$ ${command}`);

          const normalized = command.toLowerCase();
          if (normalized === 'help') {
            pushDataLog('명령어: help | status | list features | clear features');
            return;
          }
          if (normalized === 'status') {
            const name = state.dataProcessing.lastFileName || '-';
            const count = state.dataProcessing.features.length;
            pushDataLog(`lastFile=${name}, features=${count}`);
            return;
          }
          if (normalized === 'list features') {
            if (state.dataProcessing.features.length === 0) {
              pushDataLog('features: []');
              return;
            }
            pushDataLog(`features: ${state.dataProcessing.features.join(', ')}`);
            return;
          }
          if (normalized === 'clear features') {
            state.dataProcessing.features = [];
            renderDataFeatures();
            syncStudioFeaturesFromData();
            pushDataLog('features cleared');
            return;
          }

          pushDataLog(`알 수 없는 명령어: ${command}`);
        }

        function initializeDataProcessingPanel() {
          renderDataFeatures();
          renderDataPreview();
          if (dp.commandLog) {
            dp.commandLog.textContent = state.dataProcessing.logs.join('\n');
          }

          dp.pickFileBtn?.addEventListener('click', () => {
            dp.fileInput?.click();
          });

          dp.fileInput?.addEventListener('change', async (event) => {
            await handleDataFileSelection(event.target.files);
            if (dp.fileInput) {
              dp.fileInput.value = '';
            }
          });

          dp.dropZone?.addEventListener('dragover', (event) => {
            event.preventDefault();
            dp.dropZone.classList.add('border-electric');
          });

          dp.dropZone?.addEventListener('dragleave', () => {
            dp.dropZone.classList.remove('border-electric');
          });

          dp.dropZone?.addEventListener('drop', async (event) => {
            event.preventDefault();
            dp.dropZone.classList.remove('border-electric');
            await handleDataFileSelection(event.dataTransfer?.files);
          });

          dp.resetUploadBtn?.addEventListener('click', () => {
            resetDataUploadState();
            dp.fileInput?.click();
          });

          dp.commandForm?.addEventListener('submit', (event) => {
            event.preventDefault();
            executeDataCommand(dp.commandInput?.value || '');
            if (dp.commandInput) {
              dp.commandInput.value = '';
              dp.commandInput.focus();
            }
          });
        }

        function renderJobs(jobs) {
          if (!Array.isArray(jobs) || jobs.length === 0) {
            dp.jobsBody.innerHTML =
              '<tr><td class="px-4 py-4 text-sm text-slate-500" colspan="5">아직 생성된 Job이 없습니다.</td></tr>';
            return;
          }

          dp.jobsBody.innerHTML = jobs
            .map((job) => {
              const badge = getStatusBadge(job.status);
              const rowCount = job?.payload?.rowCount ?? '-';
              const datasetId = job?.result?.datasetId || '-';
              const company = job?.payload?.companyName || '-';
              const sourceName = job?.payload?.sourceName || '-';

              return `
                <tr>
                  <td class="px-4 py-3 font-semibold text-slate-900">${escapeHtml(job.id.slice(0, 8))}</td>
                  <td class="px-4 py-3">
                    <p class="font-medium text-slate-900">${escapeHtml(company)}</p>
                    <p class="text-xs text-slate-500">${escapeHtml(sourceName)}</p>
                  </td>
                  <td class="px-4 py-3">
                    <span class="rounded-full px-2 py-1 text-xs ${badge.className}">${badge.label}</span>
                  </td>
                  <td class="px-4 py-3">${escapeHtml(String(rowCount))}</td>
                  <td class="px-4 py-3 text-xs text-slate-600">
                    <p class="font-mono">${escapeHtml(datasetId === '-' ? '-' : datasetId.slice(0, 12))}</p>
                    <p class="mt-1 text-slate-400">${escapeHtml(formatTime(job.completedAt || job.startedAt || job.createdAt))}</p>
                  </td>
                </tr>
              `;
            })
            .join('');
        }

        function renderDatasets(datasets) {
          if (!Array.isArray(datasets) || datasets.length === 0) {
            dp.datasetList.innerHTML =
              '<li class="rounded-xl border border-slate-200 bg-white p-3 text-slate-500">아직 생성된 데이터셋이 없습니다.</li>';
            return;
          }

          dp.datasetList.innerHTML = datasets
            .slice(0, 5)
            .map((dataset) => {
              const mappedColumns = dataset.mappedColumns ?? '-';
              return `
                <li class="rounded-xl border border-slate-200 bg-white p-3">
                  <p class="font-mono text-xs text-slate-700">${escapeHtml(dataset.id.slice(0, 12))}</p>
                  <p class="mt-1 text-sm font-semibold text-slate-900">${escapeHtml(dataset.companyName || '-')}</p>
                  <p class="mt-1 text-xs text-slate-500">rows: ${escapeHtml(String(dataset.rowCount || 0))} · mapped: ${escapeHtml(
                String(mappedColumns)
              )}</p>
                </li>
              `;
            })
            .join('');
        }

        function renderDataMetrics(jobs, datasets) {
          const total = jobs.length;
          const active = jobs.filter((job) => job.status === 'pending' || job.status === 'running').length;
          const done = jobs.filter((job) => job.status === 'completed').length;
          const failed = jobs.filter((job) => job.status === 'failed').length;

          dp.metricJobsTotal.textContent = String(total);
          dp.metricJobsActive.textContent = String(active);
          dp.metricJobsDone.textContent = String(done);
          dp.metricJobsFailed.textContent = String(failed);
          dp.metricDatasets.textContent = String(datasets.length);
        }

        function renderAgents(agents) {
          if (!Array.isArray(agents) || agents.length === 0) {
            ac.list.innerHTML =
              '<li class="rounded-xl border border-slate-200 bg-white p-3 text-slate-500">아직 생성된 Agent가 없습니다.</li>';
            return;
          }

          ac.list.innerHTML = agents
            .slice(0, 6)
            .map((agent) => {
              const fullSkills = Array.isArray(agent.skills) && agent.skills.length > 0 ? agent.skills.join(', ') : 'none';
              const displaySkills = truncateForDisplay(fullSkills, 80);
              const avatar = agent.avatarUrl
                ? `<img src="${escapeHtml(agent.avatarUrl)}" alt="${escapeHtml(agent.name)} avatar" class="h-10 w-10 rounded-xl border border-slate-200 bg-white object-cover" />`
                : '<span class="flex h-10 w-10 items-center justify-center rounded-xl border border-slate-200 bg-white text-xs text-slate-400">N/A</span>';
              return `
                <li class="rounded-xl border border-slate-200 bg-white p-3">
                  <div class="flex items-start gap-3">
                    ${avatar}
                    <div class="min-w-0">
                      <p class="font-semibold text-slate-900">${escapeHtml(agent.name)}</p>
                      <p class="mt-1 truncate text-xs text-slate-500">model: ${escapeHtml(agent.modelTier)}</p>
                      <p class="mt-1 truncate text-xs text-slate-500" title="skills: ${escapeHtml(fullSkills)}">skills: ${escapeHtml(displaySkills)}</p>
                    </div>
                  </div>
                </li>
              `;
            })
            .join('');
        }

        const studioNodeWidth = 176;
        const studioNodeHeight = 108;
        const studioMinZoom = 0.5;
        const studioMaxZoom = 1.8;

        function clamp(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }

        function roundToTwo(value) {
          return Math.round(value * 100) / 100;
        }

        function getStudioViewport() {
          if (!ad.canvas) {
            return {
              zoom: state.deploymentStudio.zoom,
              width: 0,
              height: 0,
              maxX: 12,
              maxY: 12,
            };
          }

          const rect = ad.canvas.getBoundingClientRect();
          const zoom = state.deploymentStudio.zoom;
          const width = Math.max(rect.width / zoom, studioNodeWidth + 24);
          const height = Math.max(rect.height / zoom, studioNodeHeight + 24);
          const maxX = Math.max(12, width - studioNodeWidth - 12);
          const maxY = Math.max(12, height - studioNodeHeight - 12);

          return {
            zoom,
            width,
            height,
            maxX,
            maxY,
          };
        }

        function syncStudioViewport() {
          if (!ad.stage || !ad.edgeLayer || !ad.nodeLayer) {
            return;
          }

          const viewport = getStudioViewport();
          ad.stage.style.width = `${viewport.width}px`;
          ad.stage.style.height = `${viewport.height}px`;
          ad.stage.style.transform = `scale(${viewport.zoom})`;
          ad.edgeLayer.setAttribute('viewBox', `0 0 ${viewport.width} ${viewport.height}`);
        }

        function renderZoomLabel() {
          if (!ad.zoomLabel) {
            return;
          }
          ad.zoomLabel.textContent = `${Math.round(state.deploymentStudio.zoom * 100)}%`;
        }

        function setStudioZoom(nextZoom, { log = true } = {}) {
          const zoom = clamp(roundToTwo(nextZoom), studioMinZoom, studioMaxZoom);
          if (zoom === state.deploymentStudio.zoom) {
            return;
          }
          state.deploymentStudio.zoom = zoom;
          syncStudioViewport();
          renderStudioNodes();
          renderZoomLabel();
          if (log) {
            pushStudioLog(`캔버스 줌: ${Math.round(zoom * 100)}%`);
          }
        }

        function getAgentById(agentId) {
          return state.agents.find((agent) => agent.id === agentId) || null;
        }

        function getNodeById(nodeId) {
          return state.deploymentStudio.nodes.find((node) => node.id === nodeId) || null;
        }

        function getNodeTitle(node) {
          const agent = getAgentById(node.agentId);
          return agent?.name || node.agentName || node.agentId;
        }

        function getNodeFeatures(node) {
          return normalizeNodeFeatures(node?.features);
        }

        function setNodeFeatures(nodeId, features, { rerender = true } = {}) {
          const node = getNodeById(nodeId);
          if (!node) {
            return false;
          }
          node.features = normalizeNodeFeatures(features);
          if (rerender) {
            renderStudioNodes();
          }
          return true;
        }

        function renderNodeFeatureEditor() {
          if (!ad.selectedNodeMeta || !ad.nodeFeatureList || !ad.nodeFeatureEmpty) {
            return;
          }

          const selectedNode = getNodeById(state.deploymentStudio.selectedNodeId);
          const featurePool = getFeaturePool();

          if (!selectedNode) {
            ad.selectedNodeMeta.textContent = '노드를 클릭하면 사용할 feature를 설정할 수 있습니다.';
            ad.nodeFeatureList.innerHTML = '';
            ad.nodeFeatureEmpty.classList.remove('hidden');
            ad.nodeFeatureEmpty.textContent =
              featurePool.length === 0
                ? '데이터 처리 탭에서 feature를 추출하면 여기서 선택할 수 있습니다.'
                : '선택된 노드가 없습니다.';
            return;
          }

          ad.selectedNodeMeta.textContent = `${getNodeTitle(selectedNode)} (${selectedNode.id})`;
          if (featurePool.length === 0) {
            ad.nodeFeatureList.innerHTML = '';
            ad.nodeFeatureEmpty.classList.remove('hidden');
            ad.nodeFeatureEmpty.textContent = '데이터 처리 탭에서 feature를 먼저 추출하세요.';
            return;
          }

          const selectedFeatureSet = new Set(getNodeFeatures(selectedNode));
          ad.nodeFeatureEmpty.classList.add('hidden');
          ad.nodeFeatureList.innerHTML = featurePool
            .slice(0, 220)
            .map((feature) => {
              const checked = selectedFeatureSet.has(feature) ? 'checked' : '';
              return `
                <label class="flex items-center gap-2 rounded-lg border border-slate-200 bg-slate-50 px-2 py-1 text-xs text-slate-700">
                  <input data-node-feature="${escapeHtml(feature)}" type="checkbox" ${checked} class="h-3.5 w-3.5 rounded border-slate-300 text-electric focus:ring-electric" />
                  <span class="truncate">${escapeHtml(feature)}</span>
                </label>
              `;
            })
            .join('');
        }

        function pushStudioLog(message) {
          const now = new Date().toLocaleTimeString('ko-KR', {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
          });
          state.deploymentStudio.logs.push(`[${now}] ${message}`);
          state.deploymentStudio.logs = state.deploymentStudio.logs.slice(-200);
          if (ad.commandLog) {
            ad.commandLog.textContent = state.deploymentStudio.logs.join('\n');
            ad.commandLog.scrollTop = ad.commandLog.scrollHeight;
          }
        }

        function renderConnectModeButton() {
          if (!ad.connectModeBtn) {
            return;
          }
          const isOn = state.deploymentStudio.connectMode;
          ad.connectModeBtn.textContent = isOn ? '연결 모드 ON' : '연결 모드 OFF';
          ad.connectModeBtn.classList.toggle('bg-ink', isOn);
          ad.connectModeBtn.classList.toggle('text-white', isOn);
          ad.connectModeBtn.classList.toggle('border-slate-200', !isOn);
          ad.connectModeBtn.classList.toggle('bg-white', !isOn);
          ad.connectModeBtn.classList.toggle('text-slate-700', !isOn);
        }

        function renderEdgeList() {
          if (!ad.edgeList) {
            return;
          }

          if (state.deploymentStudio.edges.length === 0) {
            ad.edgeList.innerHTML =
              '<li class="rounded-lg border border-slate-100 bg-slate-50 px-2 py-1 text-slate-500">아직 연결된 노드가 없습니다.</li>';
            return;
          }

          ad.edgeList.innerHTML = state.deploymentStudio.edges
            .map((edge) => {
              const fromNode = getNodeById(edge.from);
              const toNode = getNodeById(edge.to);
              if (!fromNode || !toNode) {
                return '';
              }
              return `
                <li class="rounded-lg border border-slate-100 bg-slate-50 px-2 py-1 text-xs text-slate-700">
                  ${escapeHtml(fromNode.id)} (${escapeHtml(getNodeTitle(fromNode))}) → ${escapeHtml(toNode.id)} (${escapeHtml(getNodeTitle(toNode))})
                </li>
              `;
            })
            .filter(Boolean)
            .join('');
        }

        function renderStudioEdges() {
          if (!ad.edgeLayer) {
            return;
          }

          const edgesMarkup = state.deploymentStudio.edges
            .map((edge) => {
              const fromNode = getNodeById(edge.from);
              const toNode = getNodeById(edge.to);
              if (!fromNode || !toNode) {
                return '';
              }

              const fromCenter = {
                x: fromNode.x + studioNodeWidth / 2,
                y: fromNode.y + studioNodeHeight / 2,
              };
              const toCenter = {
                x: toNode.x + studioNodeWidth / 2,
                y: toNode.y + studioNodeHeight / 2,
              };
              const dx = toCenter.x - fromCenter.x;
              const dy = toCenter.y - fromCenter.y;

              const fromAnchor = { ...fromCenter };
              const toAnchor = { ...toCenter };
              if (Math.abs(dx) >= Math.abs(dy)) {
                const horizontalDir = dx >= 0 ? 1 : -1;
                fromAnchor.x += (studioNodeWidth / 2) * horizontalDir;
                toAnchor.x -= (studioNodeWidth / 2) * horizontalDir;
              } else {
                const verticalDir = dy >= 0 ? 1 : -1;
                fromAnchor.y += (studioNodeHeight / 2) * verticalDir;
                toAnchor.y -= (studioNodeHeight / 2) * verticalDir;
              }

              const curve = Math.max(36, Math.min(120, Math.hypot(dx, dy) * 0.25));
              let c1x = fromAnchor.x;
              let c1y = fromAnchor.y;
              let c2x = toAnchor.x;
              let c2y = toAnchor.y;

              if (Math.abs(dx) >= Math.abs(dy)) {
                const dir = dx >= 0 ? 1 : -1;
                c1x += curve * dir;
                c2x -= curve * dir;
              } else {
                const dir = dy >= 0 ? 1 : -1;
                c1y += curve * dir;
                c2y -= curve * dir;
              }

              const path = `M ${fromAnchor.x} ${fromAnchor.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${toAnchor.x} ${toAnchor.y}`;
              return `
                <path d="${path}" fill="none" stroke="#0ea5e9" stroke-width="2.5" stroke-linecap="round" marker-end="url(#adArrowHead)" />
                <circle cx="${fromAnchor.x}" cy="${fromAnchor.y}" r="3.5" fill="#0ea5e9" />
              `;
            })
            .filter(Boolean)
            .join('');

          ad.edgeLayer.innerHTML = `
            <defs>
              <marker id="adArrowHead" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto" markerUnits="strokeWidth">
                <path d="M0,0 L12,6 L0,12 Z" fill="#0ea5e9"></path>
              </marker>
            </defs>
            ${edgesMarkup}
          `;
        }

        function renderStudioNodes() {
          if (!ad.nodeLayer || !ad.canvasEmpty) {
            return;
          }

          syncStudioViewport();
          const viewport = getStudioViewport();
          const nodes = state.deploymentStudio.nodes;
          for (const node of nodes) {
            node.x = clamp(node.x, 12, viewport.maxX);
            node.y = clamp(node.y, 12, viewport.maxY);
          }
          ad.canvasEmpty.classList.toggle('hidden', nodes.length > 0);
          ad.nodeLayer.innerHTML = nodes
            .map((node) => {
              const agent = getAgentById(node.agentId);
              const skills = Array.isArray(agent?.skills) && agent.skills.length > 0 ? agent.skills.join(', ') : 'none';
              const nodeFeatures = getNodeFeatures(node);
              node.features = nodeFeatures;
              const featureSummary = nodeFeatures.length > 0 ? truncateForDisplay(nodeFeatures.join(', '), 30) : 'none';
              const avatar = agent?.avatarUrl
                ? `<img src="${escapeHtml(agent.avatarUrl)}" alt="${escapeHtml(agent.name)} avatar" class="h-8 w-8 rounded-lg border border-slate-200 bg-white object-cover" />`
                : '<span class="flex h-8 w-8 items-center justify-center rounded-lg border border-slate-200 bg-white text-[10px] text-slate-400">N/A</span>';
              const isSelected = state.deploymentStudio.connectMode
                ? state.deploymentStudio.pendingFromNodeId === node.id
                : state.deploymentStudio.selectedNodeId === node.id;
              const selectedClass = isSelected ? 'ring-2 ring-electric/60' : 'ring-0';
              const dragClass = state.deploymentStudio.connectMode ? 'cursor-pointer' : 'cursor-grab active:cursor-grabbing';

              return `
                <button
                  type="button"
                  data-node-id="${escapeHtml(node.id)}"
                  class="absolute w-44 rounded-xl border border-slate-200 bg-white p-2 text-left shadow-soft transition hover:-translate-y-0.5 ${selectedClass} ${dragClass}"
                  style="left:${node.x}px; top:${node.y}px;"
                >
                  <div class="flex items-start gap-2">
                    ${avatar}
                    <div class="min-w-0">
                      <p class="truncate text-sm font-semibold text-slate-900">${escapeHtml(agent?.name || node.agentName || node.agentId)}</p>
                      <p class="mt-0.5 truncate text-[11px] text-slate-500">model: ${escapeHtml(agent?.modelTier || 'Balanced (default)')}</p>
                      <p class="mt-0.5 truncate text-[11px] text-slate-500">skills: ${escapeHtml(skills)}</p>
                      <p class="mt-0.5 truncate text-[11px] text-slate-500">features: ${escapeHtml(featureSummary)}</p>
                    </div>
                  </div>
                  <p class="mt-1 text-[10px] text-slate-400">${escapeHtml(node.id)}</p>
                </button>
              `;
            })
            .join('');

          renderStudioEdges();
          renderEdgeList();
          renderConnectModeButton();
          renderNodeFeatureEditor();
          renderZoomLabel();
        }

        function addNodeToStudio(agentId, x, y) {
          const agent = getAgentById(agentId);
          if (!agent || !ad.canvas) {
            setNotice(ad.notice, '선택한 Agent를 찾을 수 없습니다.', 'error');
            return;
          }

          const viewport = getStudioViewport();
          const safeX = clamp(x, 12, viewport.maxX);
          const safeY = clamp(y, 12, viewport.maxY);
          const nodeId = `node-${state.deploymentStudio.nextNodeSeq++}`;

          state.deploymentStudio.nodes.push({
            id: nodeId,
            agentId: agent.id,
            agentName: agent.name,
            x: Math.round(safeX),
            y: Math.round(safeY),
            features: [],
          });

          state.deploymentStudio.selectedNodeId = nodeId;
          renderStudioNodes();
          pushStudioLog(`노드 추가: ${nodeId} (${agent.name})`);
        }

        function addEdgeToStudio(fromNodeId, toNodeId) {
          if (!fromNodeId || !toNodeId || fromNodeId === toNodeId) {
            return;
          }
          const alreadyExists = state.deploymentStudio.edges.some(
            (edge) => edge.from === fromNodeId && edge.to === toNodeId
          );
          if (alreadyExists) {
            return;
          }

          state.deploymentStudio.edges.push({
            from: fromNodeId,
            to: toNodeId,
          });
          renderStudioNodes();
        }

        function clearStudio() {
          state.deploymentStudio.nodes = [];
          state.deploymentStudio.edges = [];
          state.deploymentStudio.pendingFromNodeId = null;
          state.deploymentStudio.selectedNodeId = null;
          renderStudioNodes();
          pushStudioLog('캔버스 초기화 완료');
        }

        function executeStudioCommand(commandRaw) {
          const command = String(commandRaw || '').trim();
          if (!command) {
            return;
          }
          pushStudioLog(`$ ${command}`);

          const parts = command.split(/\s+/);
          const base = parts[0]?.toLowerCase();
          const sub = parts[1]?.toLowerCase();

          if (base === 'help') {
            pushStudioLog('명령어: help | list nodes | list edges | connect <fromNodeId> <toNodeId> | clear');
            return;
          }

          if (base === 'list' && sub === 'nodes') {
            if (state.deploymentStudio.nodes.length === 0) {
              pushStudioLog('nodes: []');
              return;
            }
            for (const node of state.deploymentStudio.nodes) {
              const features = getNodeFeatures(node);
              pushStudioLog(`${node.id} => ${getNodeTitle(node)} @ (${node.x}, ${node.y}) features=[${features.join(', ')}]`);
            }
            return;
          }

          if (base === 'list' && sub === 'edges') {
            if (state.deploymentStudio.edges.length === 0) {
              pushStudioLog('edges: []');
              return;
            }
            for (const edge of state.deploymentStudio.edges) {
              pushStudioLog(`${edge.from} -> ${edge.to}`);
            }
            return;
          }

          if (base === 'connect' && parts.length >= 3) {
            const fromNodeId = parts[1];
            const toNodeId = parts[2];
            if (!getNodeById(fromNodeId) || !getNodeById(toNodeId)) {
              pushStudioLog('노드 ID를 찾을 수 없습니다.');
              return;
            }
            addEdgeToStudio(fromNodeId, toNodeId);
            return;
          }

          if (base === 'clear') {
            clearStudio();
            return;
          }

          pushStudioLog(`알 수 없는 명령어: ${command}`);
        }

        function renderAgentSourceList(agents) {
          if (!ad.agentSourceList) {
            return;
          }

          if (!Array.isArray(agents) || agents.length === 0) {
            ad.agentSourceList.innerHTML =
              '<li class="rounded-xl border border-slate-200 bg-white p-3 text-sm text-slate-500">아직 생성된 Agent가 없습니다.</li>';
            return;
          }

          ad.agentSourceList.innerHTML = agents
            .slice(0, 20)
            .map((agent) => {
              const avatar = agent.avatarUrl
                ? `<img src="${escapeHtml(agent.avatarUrl)}" alt="${escapeHtml(agent.name)} avatar" class="h-8 w-8 rounded-lg border border-slate-200 bg-white object-cover" />`
                : '<span class="flex h-8 w-8 items-center justify-center rounded-lg border border-slate-200 bg-white text-[10px] text-slate-400">N/A</span>';
              return `
                <li
                  draggable="true"
                  data-agent-id="${escapeHtml(agent.id)}"
                  class="cursor-grab rounded-xl border border-slate-200 bg-white p-2 active:cursor-grabbing"
                >
                  <div class="flex items-start gap-2">
                    ${avatar}
                    <div class="min-w-0">
                      <p class="truncate text-sm font-semibold text-slate-900">${escapeHtml(agent.name)}</p>
                      <p class="mt-0.5 truncate text-[11px] text-slate-500">model: ${escapeHtml(agent.modelTier)}</p>
                    </div>
                  </div>
                </li>
              `;
            })
            .join('');
        }

        async function refreshDataProcessing() {
          if (refreshingData) {
            return;
          }
          refreshingData = true;
          try {
            const [jobResp, datasetResp] = await Promise.all([
              requestJson('/api/jobs?limit=40'),
              requestJson('/api/data/datasets'),
            ]);

            const jobs = Array.isArray(jobResp.jobs) ? jobResp.jobs : [];
            const datasets = Array.isArray(datasetResp.datasets) ? datasetResp.datasets : [];

            renderJobs(jobs);
            renderDatasets(datasets);
            renderDataMetrics(jobs, datasets);
          } catch (error) {
            setNotice(dp.notice, `조회 실패: ${error.message}`, 'error');
          } finally {
            refreshingData = false;
          }
        }

        async function refreshAgents() {
          if (refreshingAgents) {
            return;
          }
          refreshingAgents = true;
          try {
            const response = await requestJson('/api/agents?limit=60');
            state.agents = Array.isArray(response.agents) ? response.agents : [];
            renderAgents(state.agents);
            renderAgentSourceList(state.agents);
          } catch (error) {
            setNotice(ac.notice, `Agent 조회 실패: ${error.message}`, 'error');
          } finally {
            refreshingAgents = false;
          }
        }

        async function refreshSkills() {
          try {
            const response = await requestJson('/api/skills');
            state.skills = Array.isArray(response.skills) ? response.skills : [];
            renderSkillCatalog(state.skills);
          } catch (error) {
            renderSkillCatalog([]);
            setNotice(ac.notice, `스킬 목록 조회 실패: ${error.message}`, 'error');
          }
        }

        async function drawRandomAvatar() {
          if (state.ui.avatarLoading) {
            return;
          }

          const previousAvatar = state.selectedAvatar;
          const startedAt = Date.now();
          setAvatarLoading(true);
          try {
            const response = await fetchRandomAvatarWithRetry(2);
            const nextAvatar = response.avatar || null;
            if (nextAvatar?.url) {
              await preloadImage(nextAvatar.url);
            }
            renderSelectedAvatar(nextAvatar);
            clearAvatarNoticeIfNeeded();
          } catch (error) {
            if (!previousAvatar?.url) {
              renderSelectedAvatar(null);
            }
            if (isServerInitializationError(error)) {
              if (!previousAvatar?.url) {
                setNotice(ac.notice, '서버 초기화 중입니다. 잠시 후 다시 시도해주세요.', 'info');
              }
              return;
            }
            setNotice(ac.notice, `아바타 로드 실패: ${error.message}`, 'error');
          } finally {
            const elapsed = Date.now() - startedAt;
            const minLoadingMs = 350;
            if (elapsed < minLoadingMs) {
              await wait(minLoadingMs - elapsed);
            }
            setAvatarLoading(false);
          }
        }

        function initializeDeploymentStudio() {
          renderDeploymentFeaturePool();
          renderStudioNodes();
          let studioDrag = null;
          let suppressNodeClickOnce = false;

          ad.connectModeBtn?.addEventListener('click', () => {
            state.deploymentStudio.connectMode = !state.deploymentStudio.connectMode;
            state.deploymentStudio.pendingFromNodeId = null;
            if (state.deploymentStudio.connectMode) {
              state.deploymentStudio.selectedNodeId = null;
            }
            renderStudioNodes();
            pushStudioLog(
              state.deploymentStudio.connectMode
                ? '연결 모드 활성화: 출발 노드 -> 도착 노드를 순서대로 클릭하세요.'
                : '연결 모드 비활성화'
            );
          });

          ad.clearCanvasBtn?.addEventListener('click', () => {
            clearStudio();
          });

          ad.zoomOutBtn?.addEventListener('click', () => {
            setStudioZoom(state.deploymentStudio.zoom - 0.1);
          });

          ad.zoomInBtn?.addEventListener('click', () => {
            setStudioZoom(state.deploymentStudio.zoom + 0.1);
          });

          ad.zoomResetBtn?.addEventListener('click', () => {
            setStudioZoom(1);
          });

          ad.canvas?.addEventListener(
            'wheel',
            (event) => {
              if (!(event.ctrlKey || event.metaKey)) {
                return;
              }
              event.preventDefault();
              const delta = event.deltaY < 0 ? 0.05 : -0.05;
              setStudioZoom(state.deploymentStudio.zoom + delta, { log: false });
            },
            { passive: false }
          );

          window.addEventListener('resize', () => {
            syncStudioViewport();
            renderStudioNodes();
          });

          ad.agentSourceList?.addEventListener('dragstart', (event) => {
            const target = event.target instanceof Element ? event.target.closest('[data-agent-id]') : null;
            if (!target || !event.dataTransfer) {
              return;
            }
            event.dataTransfer.effectAllowed = 'copy';
            event.dataTransfer.setData('text/agent-id', target.getAttribute('data-agent-id'));
          });

          ad.canvas?.addEventListener('dragover', (event) => {
            event.preventDefault();
            ad.canvas.classList.add('ring-2');
          });

          ad.canvas?.addEventListener('dragleave', () => {
            ad.canvas.classList.remove('ring-2');
          });

          ad.canvas?.addEventListener('drop', (event) => {
            event.preventDefault();
            ad.canvas.classList.remove('ring-2');
            const agentId = event.dataTransfer?.getData('text/agent-id');
            if (!agentId || !ad.canvas) {
              return;
            }

            const rect = ad.canvas.getBoundingClientRect();
            const zoom = state.deploymentStudio.zoom;
            const x = (event.clientX - rect.left) / zoom - studioNodeWidth / 2;
            const y = (event.clientY - rect.top) / zoom - studioNodeHeight / 2;
            addNodeToStudio(agentId, x, y);
          });

          ad.nodeLayer?.addEventListener('mousedown', (event) => {
            if (state.deploymentStudio.connectMode || !ad.canvas) {
              return;
            }
            if (event.button !== 0) {
              return;
            }

            const target = event.target instanceof Element ? event.target.closest('[data-node-id]') : null;
            if (!target) {
              return;
            }

            const nodeId = target.getAttribute('data-node-id');
            const node = getNodeById(nodeId);
            if (!node) {
              return;
            }

            const viewport = getStudioViewport();
            studioDrag = {
              node,
              target,
              startClientX: event.clientX,
              startClientY: event.clientY,
              startX: node.x,
              startY: node.y,
              zoom: viewport.zoom,
              maxX: viewport.maxX,
              maxY: viewport.maxY,
              moved: false,
            };
            document.body.style.userSelect = 'none';
          });

          window.addEventListener('mousemove', (event) => {
            if (!studioDrag) {
              return;
            }

            const dxScreen = event.clientX - studioDrag.startClientX;
            const dyScreen = event.clientY - studioDrag.startClientY;
            const dx = dxScreen / studioDrag.zoom;
            const dy = dyScreen / studioDrag.zoom;
            const nextX = clamp(studioDrag.startX + dx, 12, studioDrag.maxX);
            const nextY = clamp(studioDrag.startY + dy, 12, studioDrag.maxY);

            if (Math.abs(dxScreen) > 2 || Math.abs(dyScreen) > 2) {
              studioDrag.moved = true;
            }

            studioDrag.node.x = Math.round(nextX);
            studioDrag.node.y = Math.round(nextY);
            studioDrag.target.style.left = `${studioDrag.node.x}px`;
            studioDrag.target.style.top = `${studioDrag.node.y}px`;
            renderStudioEdges();
          });

          window.addEventListener('mouseup', () => {
            if (!studioDrag) {
              return;
            }

            const moved = studioDrag.moved;
            studioDrag = null;
            document.body.style.userSelect = '';

            if (moved) {
              suppressNodeClickOnce = true;
            }
          });

          ad.nodeLayer?.addEventListener('click', (event) => {
            if (suppressNodeClickOnce) {
              suppressNodeClickOnce = false;
              return;
            }
            const target = event.target instanceof Element ? event.target.closest('[data-node-id]') : null;
            if (!target) {
              return;
            }
            const nodeId = target.getAttribute('data-node-id');
            const node = getNodeById(nodeId);
            if (!node) {
              return;
            }

            if (!state.deploymentStudio.connectMode) {
              state.deploymentStudio.selectedNodeId = node.id;
              renderStudioNodes();
              return;
            }

            if (!state.deploymentStudio.pendingFromNodeId) {
              state.deploymentStudio.pendingFromNodeId = node.id;
              renderStudioNodes();
              return;
            }

            if (state.deploymentStudio.pendingFromNodeId === node.id) {
              state.deploymentStudio.pendingFromNodeId = null;
              renderStudioNodes();
              return;
            }

            addEdgeToStudio(state.deploymentStudio.pendingFromNodeId, node.id);
            state.deploymentStudio.pendingFromNodeId = null;
            renderStudioNodes();
          });

          ad.nodeFeatureList?.addEventListener('change', (event) => {
            const target = event.target;
            if (!(target instanceof HTMLInputElement) || !target.matches('input[data-node-feature]')) {
              return;
            }

            const selectedNode = getNodeById(state.deploymentStudio.selectedNodeId);
            if (!selectedNode) {
              return;
            }

            const feature = target.dataset.nodeFeature || '';
            const next = new Set(getNodeFeatures(selectedNode));
            if (target.checked) {
              next.add(feature);
            } else {
              next.delete(feature);
            }
            setNodeFeatures(selectedNode.id, Array.from(next));
          });

          ad.assignAllNodeFeaturesBtn?.addEventListener('click', () => {
            const selectedNode = getNodeById(state.deploymentStudio.selectedNodeId);
            if (!selectedNode) {
              setNotice(ad.notice, '먼저 캔버스에서 노드를 선택하세요.', 'info');
              return;
            }
            const features = getFeaturePool();
            if (features.length === 0) {
              setNotice(ad.notice, '데이터 처리 탭에서 feature를 먼저 추출하세요.', 'info');
              return;
            }
            setNodeFeatures(selectedNode.id, features);
          });

          ad.clearNodeFeaturesBtn?.addEventListener('click', () => {
            const selectedNode = getNodeById(state.deploymentStudio.selectedNodeId);
            if (!selectedNode) {
              setNotice(ad.notice, '먼저 캔버스에서 노드를 선택하세요.', 'info');
              return;
            }
            setNodeFeatures(selectedNode.id, []);
          });

          ad.commandForm?.addEventListener('submit', (event) => {
            event.preventDefault();
            const command = ad.commandInput?.value || '';
            executeStudioCommand(command);
            if (ad.commandInput) {
              ad.commandInput.value = '';
              ad.commandInput.focus();
            }
          });
        }

        async function uploadFile() {
          const companyName = dp.companyName.value.trim() || 'Unknown Company';
          const file = dp.fileInput.files?.[0];

          if (!file) {
            setNotice(dp.notice, '업로드할 파일을 선택하세요.', 'error');
            return;
          }

          const formData = new FormData();
          formData.set('companyName', companyName);
          formData.set('file', file);

          setActionButtonsDisabled(true);
          try {
            const result = await requestJson('/api/data/upload', {
              method: 'POST',
              body: formData,
            });

            setNotice(dp.notice, `Job 생성 완료: ${result.job.id}`, 'success');
            dp.fileInput.value = '';
            await refreshDataProcessing();
          } catch (error) {
            setNotice(dp.notice, `파일 업로드 실패: ${error.message}`, 'error');
          } finally {
            setActionButtonsDisabled(false);
          }
        }

        async function uploadJsonTable() {
          const companyName = dp.companyName.value.trim() || 'Unknown Company';
          let table;
          try {
            table = JSON.parse(dp.jsonInput.value);
          } catch {
            setNotice(dp.notice, 'JSON 파싱에 실패했습니다. 배열 형태인지 확인하세요.', 'error');
            return;
          }

          if (!Array.isArray(table) || table.length === 0) {
            setNotice(dp.notice, 'JSON 테이블은 비어있지 않은 배열이어야 합니다.', 'error');
            return;
          }

          setActionButtonsDisabled(true);
          try {
            const result = await requestJson('/api/data/table', {
              method: 'POST',
              headers: { 'content-type': 'application/json' },
              body: JSON.stringify({
                companyName,
                sourceName: `json-${Date.now()}`,
                table,
              }),
            });

            setNotice(dp.notice, `JSON Job 생성 완료: ${result.job.id}`, 'success');
            await refreshDataProcessing();
          } catch (error) {
            setNotice(dp.notice, `JSON 업로드 실패: ${error.message}`, 'error');
          } finally {
            setActionButtonsDisabled(false);
          }
        }

        async function runMerge() {
          const datasetIds = parseCsvLine(dp.mergeInput.value);

          setActionButtonsDisabled(true);
          try {
            const result = await requestJson('/api/data/merge', {
              method: 'POST',
              headers: { 'content-type': 'application/json' },
              body: JSON.stringify({
                datasetIds: datasetIds.length > 0 ? datasetIds : undefined,
                limit: 100,
              }),
            });

            const summary = {
              totalRows: result?.merged?.totalRows || 0,
              returnedRows: result?.merged?.returnedRows || 0,
              columns: result?.merged?.columns || [],
              sampleRows: (result?.merged?.rows || []).slice(0, 5),
            };

            dp.mergeResult.textContent = JSON.stringify(summary, null, 2);
            dp.mergeResult.classList.remove('hidden');
            setNotice(dp.notice, `Merge 완료: ${summary.totalRows} rows`, 'success');
          } catch (error) {
            setNotice(dp.notice, `Merge 실패: ${error.message}`, 'error');
          } finally {
            setActionButtonsDisabled(false);
          }
        }

        async function createAgent() {
          const name = ac.name.value.trim();
          const modelTier = String(ac.modelSelect?.value || 'Balanced (default)').trim() || 'Balanced (default)';
          const systemPrompt = ac.prompt.value.trim();
          const skills = getSelectedSkills();
          const avatarUrl = state.selectedAvatar?.url || null;

          if (!name) {
            setNotice(ac.notice, 'Agent 이름을 입력하세요.', 'error');
            return;
          }

          if (!systemPrompt) {
            setNotice(ac.notice, 'System Prompt를 입력하세요.', 'error');
            return;
          }

          setActionButtonsDisabled(true);
          try {
            const result = await requestJson('/api/agents', {
              method: 'POST',
              headers: { 'content-type': 'application/json' },
              body: JSON.stringify({
                name,
                modelTier,
                systemPrompt,
                skills,
                avatarUrl,
              }),
            });

            setNotice(ac.notice, `Agent 생성 완료: ${result.agent.name}`, 'success');
            await refreshAgents();
          } catch (error) {
            setNotice(ac.notice, `Agent 생성 실패: ${error.message}`, 'error');
          } finally {
            setActionButtonsDisabled(false);
          }
        }

        function startPolling() {
          if (pollTimer) {
            return;
          }
          pollTimer = setInterval(() => {
            Promise.all([refreshAgents()]).catch(() => {});
          }, 2500);
        }

        function stopPolling() {
          if (!pollTimer) {
            return;
          }
          clearInterval(pollTimer);
          pollTimer = null;
        }

        async function refreshMe() {
          const response = await requestJson('/api/auth/me', {
            suppressAuthRedirect: true,
          });
          state.auth.user = response?.user || null;
          updateSignedInUser(state.auth.user);
          return state.auth.user;
        }

        async function handleLoginSubmit(event) {
          event.preventDefault();
          const lockRemainingSec = Math.max(
            0,
            Math.ceil((state.auth.lockUntilMs - Date.now()) / 1000)
          );
          if (lockRemainingSec > 0) {
            setAuthNotice(`로그인 시도 제한 상태입니다. ${lockRemainingSec}초 후 다시 시도하세요.`, 'error');
            setAuthFormBusy(false);
            return;
          }

          const email = String(auth.email?.value || '').trim();
          const password = String(auth.password?.value || '');
          if (!email || !password) {
            setAuthNotice('이메일과 비밀번호를 입력하세요.', 'error');
            return;
          }

          setAuthFormBusy(true);
          setAuthNotice('로그인 중입니다...', 'info');
          try {
            const response = await requestJson('/api/auth/login', {
              method: 'POST',
              headers: { 'content-type': 'application/json' },
              body: JSON.stringify({ email, password }),
              suppressAuthRedirect: true,
            });
            clearLoginLockState();
            state.auth.user = response?.user || null;
            updateSignedInUser(state.auth.user);
            showAppShell();
            setAuthNotice('로그인 성공', 'success');
            if (auth.password) {
              auth.password.value = '';
            }
            await Promise.all([
              refreshAgents(),
              refreshSkills(),
              refreshProviderAuth(),
              refreshModelCatalog(),
              drawRandomAvatar(),
            ]);
            startPolling();
          } catch (error) {
            if (error.status === 429) {
              const retryAfterSec = Number(error.payload?.retryAfterSec || 0);
              const maxAttempts = Number(error.payload?.maxAttempts || 0);
              startLoginLockState(retryAfterSec, maxAttempts);
            } else if (error.status === 401) {
              const attemptsRemaining = Number(error.payload?.attemptsRemaining);
              const maxAttempts = Number(error.payload?.maxAttempts);
              if (Number.isFinite(attemptsRemaining) && Number.isFinite(maxAttempts)) {
                setAuthNotice(
                  `로그인 실패: ${error.message} (남은 시도 ${attemptsRemaining}/${maxAttempts})`,
                  'error'
                );
              } else {
                setAuthNotice(`로그인 실패: ${error.message}`, 'error');
              }
            } else {
              setAuthNotice(`로그인 실패: ${error.message}`, 'error');
            }
          } finally {
            setAuthFormBusy(false);
          }
        }

        async function handleLogout() {
          setActionButtonsDisabled(true);
          try {
            await requestJson('/api/auth/logout', {
              method: 'POST',
              suppressAuthRedirect: true,
            });
          } catch {
            // ignore logout errors and force local session reset
          } finally {
            state.auth.user = null;
            updateSignedInUser(null);
            clearLoginLockState();
            setActionButtonsDisabled(false);
            showAuthGate('로그아웃되었습니다.', 'info');
          }
        }

        let initializedPanels = false;
        function initializePanelsOnce() {
          if (initializedPanels) {
            return;
          }
          initializeProviderAuthPanel();
          initializeDataProcessingPanel();
          initializeDeploymentStudio();
          initializedPanels = true;
        }

        async function bootstrapAuthAndApp() {
          initializePanelsOnce();
          auth.form?.addEventListener('submit', handleLoginSubmit);
          auth.logoutBtn?.addEventListener('click', handleLogout);
          setAuthFormBusy(false);

          try {
            setAuthNotice('세션을 확인하는 중입니다.', 'info');
            const user = await refreshMe();
            if (user) {
              showAppShell();
              await Promise.all([
                refreshAgents(),
                refreshSkills(),
                refreshProviderAuth(),
                refreshModelCatalog(),
                drawRandomAvatar(),
              ]);
              startPolling();
              return;
            }
          } catch {
            // session not found
          }

          showAuthGate('로그인이 필요합니다.', 'info');
        }

        ac.clearSkillsBtn?.addEventListener('click', clearSelectedSkills);
        ac.rerollAvatarBtn?.addEventListener('click', drawRandomAvatar);
        ac.createBtn?.addEventListener('click', createAgent);

        bootstrapAuthAndApp().catch((error) => {
          console.error('auth bootstrap failed', error);
          showAuthGate(`초기화 실패: ${error.message}`, 'error');
        });

        window.addEventListener('beforeunload', () => {
          stopPolling();
          stopLoginLockTimer();
        });
      })();

    </script>
  </body>
</html>
